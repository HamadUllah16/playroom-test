---
title: PlayCanvas
description: Build multiplayer 3D games with PlayCanvas and PlayroomKit.
---

# PlayCanvas Integration

PlayCanvas is a powerful WebGL-based 3D game engine. PlayroomKit provides seamless integration for adding multiplayer functionality to your PlayCanvas games.

## Installation

Add PlayroomKit to your PlayCanvas project:

```javascript
// In your PlayCanvas script, load PlayroomKit
pc.createScript('PlayroomKit');

PlayroomKit.attributes.add('apiKey', { type: 'string' });

PlayroomKit.prototype.initialize = function() {
    // Load PlayroomKit SDK
    this.loadScript('https://cdn.PlayroomKit.com/client.js', () => {
        this.initializeMultiplayer();
    });
};

PlayroomKit.prototype.initializeMultiplayer = async function() {
    await Playroom.init(this.apiKey);
    console.log('PlayroomKit initialized!');
};
```

## Basic Setup

### Player Entity Management

```javascript
pc.createScript('multiplayerManager');

MultiplayerManager.prototype.initialize = function() {
    this.players = new Map();
    this.playerEntities = new Map();
    
    // Initialize PlayroomKit
    this.initMultiplayer();
};

MultiplayerManager.prototype.initMultiplayer = async function() {
    await Playroom.init('your-api-key');
    
    // Create or join room
    const room = await Playroom.createRoom({ maxPlayers: 8 });
    console.log(`Room created: ${room.code}`);
    
    // Set up events
    this.setupEvents();
    
    // Spawn local player
    this.spawnLocalPlayer();
};

MultiplayerManager.prototype.setupEvents = function() {
    Playroom.onPlayerJoin((player) => {
        this.spawnPlayer(player);
    });
    
    Playroom.onPlayerLeave((player) => {
        this.removePlayer(player);
    });
    
    Playroom.onStateChange('players', (playersData) => {
        this.updatePlayers(playersData);
    });
};
```

### Player Spawning

```javascript
MultiplayerManager.prototype.spawnPlayer = function(player) {
    // Create player entity
    const playerEntity = new pc.Entity(`player_${player.id}`);
    
    // Add components
    playerEntity.addComponent('model', {
        type: 'capsule'
    });
    
    playerEntity.addComponent('rigidbody', {
        type: 'dynamic',
        mass: 1
    });
    
    playerEntity.addComponent('collision', {
        type: 'capsule',
        radius: 0.5,
        height: 2
    });
    
    // Set spawn position
    const spawnPoint = this.getSpawnPoint();
    playerEntity.setPosition(spawnPoint.x, spawnPoint.y, spawnPoint.z);
    
    // Add to scene
    this.app.root.addChild(playerEntity);
    
    // Store reference
    this.playerEntities.set(player.id, playerEntity);
    
    // Add player script if it's the local player
    if (player.isMe) {
        playerEntity.addComponent('script');
        playerEntity.script.create('playerController');
        this.localPlayerEntity = playerEntity;
    }
    
    console.log(`Player ${player.name} spawned`);
};

MultiplayerManager.prototype.getSpawnPoint = function() {
    const spawnPoints = [
        { x: 0, y: 1, z: 5 },
        { x: 5, y: 1, z: 0 },
        { x: 0, y: 1, z: -5 },
        { x: -5, y: 1, z: 0 }
    ];
    
    return spawnPoints[this.playerEntities.size % spawnPoints.length];
};
```

## Player Movement

### Local Player Controller

```javascript
pc.createScript('playerController');

PlayerController.prototype.initialize = function() {
    this.speed = 5;
    this.jumpForce = 10;
    this.isGrounded = false;
    
    // Camera setup
    this.setupCamera();
    
    // Input handling
    this.setupInput();
    
    // Position sync
    this.lastSyncTime = 0;
    this.syncInterval = 100; // Sync every 100ms
};

PlayerController.prototype.setupCamera = function() {
    // Create camera entity
    this.cameraEntity = new pc.Entity('playerCamera');
    this.cameraEntity.addComponent('camera', {
        clearColor: new pc.Color(0.4, 0.6, 0.9)
    });
    
    // Position camera above and behind player
    this.cameraEntity.setPosition(0, 3, 5);
    this.cameraEntity.lookAt(this.entity.getPosition());
    
    this.entity.addChild(this.cameraEntity);
};

PlayerController.prototype.setupInput = function() {
    // Mouse look
    this.app.mouse.on(pc.EVENT_MOUSEMOVE, this.onMouseMove, this);
    this.app.mouse.on(pc.EVENT_MOUSEDOWN, this.onMouseDown, this);
    
    // Keyboard input
    this.app.keyboard.on(pc.EVENT_KEYDOWN, this.onKeyDown, this);
};

PlayerController.prototype.update = function(dt) {
    this.handleMovement(dt);
    this.syncPosition();
};

PlayerController.prototype.handleMovement = function(dt) {
    const keyboard = this.app.keyboard;
    const velocity = new pc.Vec3();
    
    // WASD movement
    if (keyboard.isPressed(pc.KEY_W)) velocity.z -= 1;
    if (keyboard.isPressed(pc.KEY_S)) velocity.z += 1;
    if (keyboard.isPressed(pc.KEY_A)) velocity.x -= 1;
    if (keyboard.isPressed(pc.KEY_D)) velocity.x += 1;
    
    // Normalize and apply speed
    if (velocity.length() > 0) {
        velocity.normalize();
        velocity.scale(this.speed);
        
        // Apply to rigidbody
        const rigidbody = this.entity.rigidbody;
        rigidbody.linearVelocity = new pc.Vec3(velocity.x, rigidbody.linearVelocity.y, velocity.z);
    }
    
    // Jump
    if (keyboard.wasPressed(pc.KEY_SPACE) && this.isGrounded) {
        this.entity.rigidbody.applyImpulse(0, this.jumpForce, 0);
        this.isGrounded = false;
    }
};

PlayerController.prototype.syncPosition = function() {
    const now = Date.now();
    if (now - this.lastSyncTime > this.syncInterval) {
        const pos = this.entity.getPosition();
        const rot = this.entity.getRotation();
        
        Playroom.setState(`players.${Playroom.getMyPlayer().id}.transform`, {
            position: { x: pos.x, y: pos.y, z: pos.z },
            rotation: { x: rot.x, y: rot.y, z: rot.z, w: rot.w }
        });
        
        this.lastSyncTime = now;
    }
};
```

### Remote Player Updates

```javascript
MultiplayerManager.prototype.updatePlayers = function(playersData) {
    Object.entries(playersData).forEach(([playerId, playerData]) => {
        const playerEntity = this.playerEntities.get(playerId);
        
        if (playerEntity && playerData.transform && playerId !== Playroom.getMyPlayer().id) {
            // Smoothly interpolate to new position
            const targetPos = new pc.Vec3(
                playerData.transform.position.x,
                playerData.transform.position.y,
                playerData.transform.position.z
            );
            
            const targetRot = new pc.Quat(
                playerData.transform.rotation.x,
                playerData.transform.rotation.y,
                playerData.transform.rotation.z,
                playerData.transform.rotation.w
            );
            
            // Tween to new position
            this.tweenTransform(playerEntity, targetPos, targetRot);
        }
    });
};

MultiplayerManager.prototype.tweenTransform = function(entity, targetPos, targetRot) {
    // Position tween
    entity.tween(entity.getPosition())
        .to(targetPos, 0.2, pc.Linear)
        .start();
    
    // Rotation tween
    entity.tween(entity.getRotation())
        .to(targetRot, 0.2, pc.Linear)
        .start();
};
```

## Game Objects

### Synchronized Objects

```javascript
pc.createScript('syncedObject');

SyncedObject.attributes.add('objectId', { type: 'string' });

SyncedObject.prototype.initialize = function() {
    // Register object in global state
    if (this.entity.script.multiplayerManager.isHost()) {
        this.registerObject();
    }
    
    // Listen for object updates
    Playroom.onStateChange(`objects.${this.objectId}`, (objectData) => {
        this.updateFromState(objectData);
    });
};

SyncedObject.prototype.registerObject = function() {
    const pos = this.entity.getPosition();
    const rot = this.entity.getRotation();
    
    Playroom.setState(`objects.${this.objectId}`, {
        position: { x: pos.x, y: pos.y, z: pos.z },
        rotation: { x: rot.x, y: rot.y, z: rot.z, w: rot.w },
        active: true
    });
};

SyncedObject.prototype.updateTransform = function() {
    if (this.entity.script.multiplayerManager.isHost()) {
        const pos = this.entity.getPosition();
        const rot = this.entity.getRotation();
        
        Playroom.setState(`objects.${this.objectId}.position`, { x: pos.x, y: pos.y, z: pos.z });
        Playroom.setState(`objects.${this.objectId}.rotation`, { x: rot.x, y: rot.y, z: rot.z, w: rot.w });
    }
};

SyncedObject.prototype.updateFromState = function(objectData) {
    if (objectData.position) {
        this.entity.setPosition(objectData.position.x, objectData.position.y, objectData.position.z);
    }
    
    if (objectData.rotation) {
        this.entity.setRotation(objectData.rotation.x, objectData.rotation.y, objectData.rotation.z, objectData.rotation.w);
    }
    
    this.entity.enabled = objectData.active;
};
```

## Interaction System

### Pickup Objects

```javascript
pc.createScript('pickup');

Pickup.attributes.add('value', { type: 'number', default: 10 });

Pickup.prototype.initialize = function() {
    // Add trigger for pickup detection
    this.entity.collision.on('triggerenter', this.onTriggerEnter, this);
    
    // Generate unique ID
    this.pickupId = `pickup_${Math.random().toString(36).substr(2, 9)}`;
    
    // Register in state if host
    if (this.isHost()) {
        Playroom.setState(`pickups.${this.pickupId}`, {
            position: this.entity.getPosition(),
            collected: false,
            value: this.value
        });
    }
    
    // Listen for pickup events
    Playroom.onStateChange(`pickups.${this.pickupId}`, (pickupData) => {
        if (pickupData.collected) {
            this.onCollected();
        }
    });
};

Pickup.prototype.onTriggerEnter = function(other) {
    // Check if it's a player
    if (other.name.startsWith('player_')) {
        const playerId = other.name.replace('player_', '');
        
        if (playerId === Playroom.getMyPlayer().id) {
            // Collect the pickup
            this.collect();
        }
    }
};

Pickup.prototype.collect = function() {
    // Mark as collected in state
    Playroom.setState(`pickups.${this.pickupId}.collected`, true);
    
    // Update player score
    const currentScore = Playroom.getState(`players.${Playroom.getMyPlayer().id}.score`) || 0;
    Playroom.setState(`players.${Playroom.getMyPlayer().id}.score`, currentScore + this.value);
    
    // Play sound effect
    this.entity.sound.play('pickup');
};

Pickup.prototype.onCollected = function() {
    // Disable the pickup
    this.entity.enabled = false;
    
    // Respawn after delay (if host)
    if (this.isHost()) {
        setTimeout(() => {
            this.respawn();
        }, 5000);
    }
};

Pickup.prototype.respawn = function() {
    // Reset state
    Playroom.setState(`pickups.${this.pickupId}`, {
        position: this.getRandomSpawnPoint(),
        collected: false,
        value: this.value
    });
    
    this.entity.enabled = true;
};
```

## UI Integration

### HUD Display

```javascript
pc.createScript('gameHUD');

GameHUD.prototype.initialize = function() {
    this.createUI();
    this.updateInterval = setInterval(() => {
        this.updateHUD();
    }, 100);
};

GameHUD.prototype.createUI = function() {
    // Create screen
    this.screen = new pc.Entity('HUD');
    this.screen.addComponent('screen', {
        referenceResolution: new pc.Vec2(1920, 1080),
        scaleBlend: 0.5,
        scaleMode: pc.SCALEMODE_BLEND,
        screenSpace: true
    });
    
    this.app.root.addChild(this.screen);
    
    // Score display
    this.scoreElement = new pc.Entity('score');
    this.scoreElement.addComponent('element', {
        type: pc.ELEMENTTYPE_TEXT,
        anchor: [0, 1, 0, 1],
        pivot: [0, 1],
        margin: [20, -20, 0, 0],
        text: 'Score: 0',
        fontAsset: this.app.assets.find('Arial', 'font'),
        fontSize: 32,
        color: new pc.Color(1, 1, 1)
    });
    
    this.screen.addChild(this.scoreElement);
    
    // Player list
    this.playerListElement = new pc.Entity('playerList');
    this.playerListElement.addComponent('element', {
        type: pc.ELEMENTTYPE_TEXT,
        anchor: [1, 1, 1, 1],
        pivot: [1, 1],
        margin: [-20, -20, 0, 0],
        text: 'Players: 0',
        fontAsset: this.app.assets.find('Arial', 'font'),
        fontSize: 24,
        color: new pc.Color(1, 1, 1)
    });
    
    this.screen.addChild(this.playerListElement);
};

GameHUD.prototype.updateHUD = function() {
    const playersData = Playroom.getState('players') || {};
    const myPlayer = playersData[Playroom.getMyPlayer().id];
    
    // Update score
    if (myPlayer) {
        this.scoreElement.element.text = `Score: ${myPlayer.score || 0}`;
    }
    
    // Update player list
    const playerNames = Object.values(playersData).map(player => player.name || 'Player');
    this.playerListElement.element.text = `Players: ${playerNames.length}\n${playerNames.join('\n')}`;
};
```

## Physics Synchronization

### Networked Physics

```javascript
pc.createScript('networkedPhysics');

NetworkedPhysics.prototype.initialize = function() {
    this.isOwner = false;
    this.lastSyncTime = 0;
    this.syncRate = 10; // 10 times per second
    
    // Check ownership
    this.checkOwnership();
};

NetworkedPhysics.prototype.checkOwnership = function() {
    // First player to interact becomes owner
    const objectState = Playroom.getState(`objects.${this.entity.name}`);
    
    if (!objectState || !objectState.owner) {
        this.claimOwnership();
    }
};

NetworkedPhysics.prototype.claimOwnership = function() {
    this.isOwner = true;
    Playroom.setState(`objects.${this.entity.name}.owner`, Playroom.getMyPlayer().id);
};

NetworkedPhysics.prototype.update = function(dt) {
    if (this.isOwner) {
        this.syncPhysics();
    } else {
        this.applyRemotePhysics();
    }
};

NetworkedPhysics.prototype.syncPhysics = function() {
    const now = Date.now();
    if (now - this.lastSyncTime > 1000 / this.syncRate) {
        const rigidbody = this.entity.rigidbody;
        
        Playroom.setState(`objects.${this.entity.name}.physics`, {
            position: this.entity.getPosition(),
            rotation: this.entity.getRotation(),
            linearVelocity: rigidbody.linearVelocity,
            angularVelocity: rigidbody.angularVelocity
        });
        
        this.lastSyncTime = now;
    }
};

NetworkedPhysics.prototype.applyRemotePhysics = function() {
    const physicsData = Playroom.getState(`objects.${this.entity.name}.physics`);
    
    if (physicsData) {
        // Apply position and rotation
        this.entity.setPosition(physicsData.position);
        this.entity.setRotation(physicsData.rotation);
        
        // Apply velocities
        const rigidbody = this.entity.rigidbody;
        rigidbody.linearVelocity = physicsData.linearVelocity;
        rigidbody.angularVelocity = physicsData.angularVelocity;
    }
};
```

## Best Practices

1. **Use Entity Hierarchy** - Organize multiplayer objects in a clear hierarchy
2. **Optimize Network Traffic** - Only sync necessary data and use appropriate frequencies
3. **Handle Ownership** - Implement clear ownership rules for physics objects
4. **Graceful Disconnection** - Handle player disconnections smoothly
5. **Mobile Optimization** - Ensure good performance on mobile devices
6. **Asset Management** - Preload assets for smooth multiplayer experience 