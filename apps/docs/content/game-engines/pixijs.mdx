---
title: PixiJS
description: Build fast 2D multiplayer games with PixiJS and PlayroomKit.
---

# PixiJS Integration

PixiJS is a powerful 2D WebGL renderer that enables fast, smooth graphics for web games. Combined with PlayroomKit, you can create responsive multiplayer 2D games with excellent performance.

## Installation

```bash
npm install pixi.js @PlayroomKit/client
```

For React projects:
```bash
npm install pixi.js @PlayroomKit/client @pixi/react
```

## Basic Setup

### Core Game Setup

```javascript
import * as PIXI from 'pixi.js';
import { Playroom } from '@PlayroomKit/client';

class PixiMultiplayerGame {
  constructor() {
    this.app = null;
    this.players = new Map();
    this.gameContainer = null;
  }
  
  async init() {
    // Initialize PlayroomKit
    await Playroom.init('your-api-key');
    
    // Create PIXI application
    this.app = new PIXI.Application({
      width: 800,
      height: 600,
      backgroundColor: 0x1099bb,
      resolution: window.devicePixelRatio || 1,
      antialias: true
    });
    
    // Add to DOM
    document.getElementById('game-container').appendChild(this.app.view);
    
    // Setup game
    this.setupGame();
    this.setupMultiplayer();
    
    // Start game loop
    this.app.ticker.add(this.gameLoop, this);
  }
  
  setupGame() {
    // Create main game container
    this.gameContainer = new PIXI.Container();
    this.app.stage.addChild(this.gameContainer);
    
    // Create background
    this.createBackground();
    
    // Create UI layer
    this.createUI();
  }
  
  setupMultiplayer() {
    // Handle player events
    Playroom.onPlayerJoin((player) => {
      this.addPlayer(player);
    });
    
    Playroom.onPlayerLeave((player) => {
      this.removePlayer(player);
    });
    
    // Handle state changes
    Playroom.onStateChange('players', (playersData) => {
      this.updatePlayers(playersData);
    });
    
    // Handle game events
    this.setupGameEvents();
  }
}
```

### Player Management

```javascript
class PixiPlayer {
  constructor(playerData) {
    this.id = playerData.id;
    this.name = playerData.name;
    this.container = new PIXI.Container();
    
    this.createPlayerSprite();
    this.createNameTag();
    this.setupMovement();
  }
  
  createPlayerSprite() {
    // Create player sprite
    this.sprite = PIXI.Sprite.from('player.png');
    this.sprite.anchor.set(0.5);
    this.sprite.scale.set(0.5);
    
    // Add glow filter
    const glowFilter = new PIXI.filters.GlowFilter({
      color: 0xFFFFFF,
      distance: 15,
      outerStrength: 2,
      innerStrength: 1
    });
    
    this.sprite.filters = [glowFilter];
    this.container.addChild(this.sprite);
  }
  
  createNameTag() {
    // Create name text
    this.nameText = new PIXI.Text(this.name, {
      fontSize: 16,
      fill: 0xFFFFFF,
      stroke: 0x000000,
      strokeThickness: 2,
      fontFamily: 'Arial'
    });
    
    this.nameText.anchor.set(0.5);
    this.nameText.y = -40;
    this.container.addChild(this.nameText);
  }
  
  setupMovement() {
    this.position = { x: 400, y: 300 };
    this.velocity = { x: 0, y: 0 };
    this.speed = 200;
    
    // Set initial position
    this.container.x = this.position.x;
    this.container.y = this.position.y;
  }
  
  update(deltaTime) {
    // Apply velocity
    this.position.x += this.velocity.x * deltaTime;
    this.position.y += this.velocity.y * deltaTime;
    
    // Boundary checking
    this.position.x = Math.max(50, Math.min(750, this.position.x));
    this.position.y = Math.max(50, Math.min(550, this.position.y));
    
    // Smooth movement
    this.container.x += (this.position.x - this.container.x) * 0.1;
    this.container.y += (this.position.y - this.container.y) * 0.1;
    
    // Update rotation based on movement
    if (Math.abs(this.velocity.x) > 0.1 || Math.abs(this.velocity.y) > 0.1) {
      this.sprite.rotation = Math.atan2(this.velocity.y, this.velocity.x);
    }
  }
  
  setPosition(x, y) {
    this.position.x = x;
    this.position.y = y;
  }
  
  setVelocity(x, y) {
    this.velocity.x = x;
    this.velocity.y = y;
  }
}
```

## Input Handling

### Keyboard Controls

```javascript
class InputManager {
  constructor() {
    this.keys = {};
    this.setupKeyboardEvents();
  }
  
  setupKeyboardEvents() {
    // Key down
    window.addEventListener('keydown', (e) => {
      this.keys[e.code] = true;
      this.handleKeyDown(e.code);
    });
    
    // Key up
    window.addEventListener('keyup', (e) => {
      this.keys[e.code] = false;
      this.handleKeyUp(e.code);
    });
  }
  
  handleKeyDown(keyCode) {
    const player = Playroom.getMyPlayer();
    
    switch (keyCode) {
      case 'Space':
        Playroom.rpc('playerJump', { playerId: player.id });
        break;
      case 'KeyF':
        Playroom.rpc('playerAttack', { playerId: player.id });
        break;
    }
  }
  
  updateMovement() {
    const player = Playroom.getMyPlayer();
    let velocityX = 0;
    let velocityY = 0;
    
    // WASD movement
    if (this.keys['KeyW']) velocityY -= 1;
    if (this.keys['KeyS']) velocityY += 1;
    if (this.keys['KeyA']) velocityX -= 1;
    if (this.keys['KeyD']) velocityX += 1;
    
    // Normalize diagonal movement
    if (velocityX !== 0 && velocityY !== 0) {
      velocityX *= 0.707;
      velocityY *= 0.707;
    }
    
    // Sync velocity
    Playroom.setState(`players.${player.id}.velocity`, {
      x: velocityX * 200,
      y: velocityY * 200
    });
  }
}
```

### Mouse/Touch Controls

```javascript
class TouchInputManager {
  constructor(app) {
    this.app = app;
    this.isPointerDown = false;
    this.setupPointerEvents();
  }
  
  setupPointerEvents() {
    // Make stage interactive
    this.app.stage.interactive = true;
    
    // Pointer events
    this.app.stage.on('pointerdown', (e) => {
      this.isPointerDown = true;
      this.handlePointerDown(e);
    });
    
    this.app.stage.on('pointermove', (e) => {
      if (this.isPointerDown) {
        this.handlePointerMove(e);
      }
    });
    
    this.app.stage.on('pointerup', (e) => {
      this.isPointerDown = false;
      this.handlePointerUp(e);
    });
  }
  
  handlePointerDown(event) {
    const player = Playroom.getMyPlayer();
    const globalPos = event.data.global;
    
    // Move towards click position
    const playerPos = Playroom.getState(`players.${player.id}.position`);
    
    if (playerPos) {
      const direction = {
        x: globalPos.x - playerPos.x,
        y: globalPos.y - playerPos.y
      };
      
      // Normalize
      const length = Math.sqrt(direction.x ** 2 + direction.y ** 2);
      if (length > 0) {
        direction.x /= length;
        direction.y /= length;
      }
      
      // Set target position
      Playroom.setState(`players.${player.id}.target`, {
        x: globalPos.x,
        y: globalPos.y
      });
    }
  }
}
```

## Game Objects & Entities

### Collectible Items

```javascript
class Collectible extends PIXI.Container {
  constructor(id, type, position) {
    super();
    
    this.id = id;
    this.type = type;
    this.collected = false;
    
    this.createSprite();
    this.setupAnimation();
    this.setupInteraction();
    
    this.x = position.x;
    this.y = position.y;
  }
  
  createSprite() {
    const colors = {
      coin: 0xFFD700,
      gem: 0xFF1493,
      powerup: 0x00FF00
    };
    
    // Create graphic
    this.sprite = new PIXI.Graphics();
    this.sprite.beginFill(colors[this.type] || 0xFFFFFF);
    this.sprite.drawCircle(0, 0, 15);
    this.sprite.endFill();
    
    // Add glow effect
    const glowFilter = new PIXI.filters.GlowFilter({
      color: colors[this.type] || 0xFFFFFF,
      distance: 10,
      outerStrength: 2
    });
    
    this.sprite.filters = [glowFilter];
    this.addChild(this.sprite);
  }
  
  setupAnimation() {
    // Floating animation
    this.floatTween = {
      time: 0,
      amplitude: 10,
      frequency: 2
    };
    
    // Rotation animation
    this.rotationSpeed = 0.02;
  }
  
  setupInteraction() {
    this.interactive = true;
    this.buttonMode = true;
    
    this.on('pointerdown', () => {
      this.collect();
    });
  }
  
  update(deltaTime) {
    if (this.collected) return;
    
    // Floating animation
    this.floatTween.time += deltaTime;
    this.y += Math.sin(this.floatTween.time * this.floatTween.frequency) * this.floatTween.amplitude * deltaTime;
    
    // Rotation
    this.sprite.rotation += this.rotationSpeed;
  }
  
  collect() {
    if (this.collected) return;
    
    this.collected = true;
    
    // Create collection effect
    this.createCollectionEffect();
    
    // Notify other players
    Playroom.rpc('itemCollected', {
      itemId: this.id,
      playerId: Playroom.getMyPlayer().id,
      type: this.type
    });
    
    // Remove from game
    setTimeout(() => {
      this.parent?.removeChild(this);
    }, 500);
  }
  
  createCollectionEffect() {
    // Particle burst effect
    const particleContainer = new PIXI.ParticleContainer(100);
    this.parent.addChild(particleContainer);
    
    for (let i = 0; i < 20; i++) {
      const particle = PIXI.Sprite.from('particle.png');
      particle.x = this.x;
      particle.y = this.y;
      particle.scale.set(0.5);
      particle.tint = Math.random() * 0xFFFFFF;
      
      // Random velocity
      const angle = Math.random() * Math.PI * 2;
      const speed = 100 + Math.random() * 100;
      
      particle.vx = Math.cos(angle) * speed;
      particle.vy = Math.sin(angle) * speed;
      
      particleContainer.addChild(particle);
      
      // Animate particle
      this.animateParticle(particle, particleContainer);
    }
  }
  
  animateParticle(particle, container) {
    const animate = () => {
      particle.x += particle.vx * 0.016;
      particle.y += particle.vy * 0.016;
      particle.alpha -= 0.02;
      particle.scale.x -= 0.01;
      particle.scale.y -= 0.01;
      
      if (particle.alpha <= 0) {
        container.removeChild(particle);
        return;
      }
      
      requestAnimationFrame(animate);
    };
    
    animate();
  }
}
```

### Projectiles System

```javascript
class ProjectileSystem {
  constructor(container) {
    this.container = container;
    this.projectiles = new Map();
    this.projectilePool = [];
  }
  
  createProjectile(startPos, targetPos, type = 'bullet') {
    const projectile = this.getPooledProjectile() || this.createNewProjectile();
    
    // Reset projectile
    projectile.x = startPos.x;
    projectile.y = startPos.y;
    projectile.visible = true;
    projectile.alpha = 1;
    
    // Calculate direction
    const direction = {
      x: targetPos.x - startPos.x,
      y: targetPos.y - startPos.y
    };
    
    const length = Math.sqrt(direction.x ** 2 + direction.y ** 2);
    direction.x /= length;
    direction.y /= length;
    
    // Set velocity
    const speed = 400;
    projectile.velocity = {
      x: direction.x * speed,
      y: direction.y * speed
    };
    
    projectile.rotation = Math.atan2(direction.y, direction.x);
    
    // Add to active projectiles
    const id = Date.now() + Math.random();
    projectile.id = id;
    this.projectiles.set(id, projectile);
    
    this.container.addChild(projectile);
    
    return projectile;
  }
  
  createNewProjectile() {
    const projectile = new PIXI.Graphics();
    projectile.beginFill(0xFFFF00);
    projectile.drawRect(-5, -2, 10, 4);
    projectile.endFill();
    
    return projectile;
  }
  
  getPooledProjectile() {
    return this.projectilePool.pop();
  }
  
  update(deltaTime) {
    this.projectiles.forEach((projectile, id) => {
      // Move projectile
      projectile.x += projectile.velocity.x * deltaTime;
      projectile.y += projectile.velocity.y * deltaTime;
      
      // Check bounds
      if (projectile.x < -50 || projectile.x > 850 || 
          projectile.y < -50 || projectile.y > 650) {
        this.removeProjectile(id);
      }
    });
  }
  
  removeProjectile(id) {
    const projectile = this.projectiles.get(id);
    if (projectile) {
      this.container.removeChild(projectile);
      this.projectilePool.push(projectile);
      this.projectiles.delete(id);
    }
  }
  
  checkCollisions(targets) {
    this.projectiles.forEach((projectile, id) => {
      targets.forEach(target => {
        if (this.isColliding(projectile, target)) {
          this.onCollision(projectile, target);
          this.removeProjectile(id);
        }
      });
    });
  }
  
  isColliding(obj1, obj2) {
    const dx = obj1.x - obj2.x;
    const dy = obj1.y - obj2.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    return distance < 30; // Collision radius
  }
}
```

## Visual Effects

### Particle Systems

```javascript
class ParticleSystem extends PIXI.Container {
  constructor() {
    super();
    
    this.particles = [];
    this.emitters = new Map();
  }
  
  createEmitter(config) {
    const emitter = {
      ...config,
      particles: [],
      timer: 0
    };
    
    const id = Date.now() + Math.random();
    this.emitters.set(id, emitter);
    
    return id;
  }
  
  update(deltaTime) {
    this.emitters.forEach((emitter, id) => {
      this.updateEmitter(emitter, deltaTime);
    });
  }
  
  updateEmitter(emitter, deltaTime) {
    emitter.timer += deltaTime;
    
    // Spawn particles
    if (emitter.timer >= emitter.spawnRate) {
      this.spawnParticle(emitter);
      emitter.timer = 0;
    }
    
    // Update existing particles
    emitter.particles.forEach((particle, index) => {
      this.updateParticle(particle, deltaTime);
      
      // Remove dead particles
      if (particle.life <= 0) {
        this.removeChild(particle.sprite);
        emitter.particles.splice(index, 1);
      }
    });
  }
  
  spawnParticle(emitter) {
    const particle = {
      sprite: new PIXI.Graphics(),
      x: emitter.x + (Math.random() - 0.5) * emitter.spawnArea.width,
      y: emitter.y + (Math.random() - 0.5) * emitter.spawnArea.height,
      vx: (Math.random() - 0.5) * emitter.velocity.x,
      vy: (Math.random() - 0.5) * emitter.velocity.y,
      life: emitter.particleLife,
      maxLife: emitter.particleLife,
      size: emitter.size.min + Math.random() * (emitter.size.max - emitter.size.min),
      color: emitter.color
    };
    
    // Create sprite
    particle.sprite.beginFill(particle.color);
    particle.sprite.drawCircle(0, 0, particle.size);
    particle.sprite.endFill();
    particle.sprite.x = particle.x;
    particle.sprite.y = particle.y;
    
    this.addChild(particle.sprite);
    emitter.particles.push(particle);
  }
  
  updateParticle(particle, deltaTime) {
    // Update position
    particle.x += particle.vx * deltaTime;
    particle.y += particle.vy * deltaTime;
    
    // Update life
    particle.life -= deltaTime;
    
    // Update sprite
    particle.sprite.x = particle.x;
    particle.sprite.y = particle.y;
    particle.sprite.alpha = particle.life / particle.maxLife;
    
    // Scale over time
    const lifeRatio = particle.life / particle.maxLife;
    particle.sprite.scale.set(lifeRatio);
  }
}
```

### Screen Effects

```javascript
class ScreenEffects {
  constructor(app) {
    this.app = app;
    this.effects = [];
    this.setupFilters();
  }
  
  setupFilters() {
    // Screen shake
    this.shakeFilter = {
      intensity: 0,
      duration: 0,
      time: 0
    };
    
    // Flash effect
    this.flashFilter = new PIXI.Graphics();
    this.flashFilter.beginFill(0xFFFFFF);
    this.flashFilter.drawRect(0, 0, this.app.screen.width, this.app.screen.height);
    this.flashFilter.endFill();
    this.flashFilter.alpha = 0;
    this.flashFilter.blendMode = PIXI.BLEND_MODES.ADD;
    
    this.app.stage.addChild(this.flashFilter);
  }
  
  screenShake(intensity = 10, duration = 0.5) {
    this.shakeFilter.intensity = intensity;
    this.shakeFilter.duration = duration;
    this.shakeFilter.time = 0;
  }
  
  screenFlash(color = 0xFFFFFF, intensity = 0.8, duration = 0.2) {
    this.flashFilter.tint = color;
    this.flashFilter.alpha = intensity;
    
    // Fade out
    const fadeOut = () => {
      this.flashFilter.alpha -= intensity * (1/60) / duration;
      
      if (this.flashFilter.alpha <= 0) {
        this.flashFilter.alpha = 0;
        return;
      }
      
      requestAnimationFrame(fadeOut);
    };
    
    fadeOut();
  }
  
  update(deltaTime) {
    this.updateScreenShake(deltaTime);
  }
  
  updateScreenShake(deltaTime) {
    if (this.shakeFilter.duration > 0) {
      this.shakeFilter.time += deltaTime;
      
      const progress = this.shakeFilter.time / this.shakeFilter.duration;
      const currentIntensity = this.shakeFilter.intensity * (1 - progress);
      
      // Apply shake
      this.app.stage.x = (Math.random() - 0.5) * currentIntensity;
      this.app.stage.y = (Math.random() - 0.5) * currentIntensity;
      
      if (progress >= 1) {
        this.shakeFilter.duration = 0;
        this.app.stage.x = 0;
        this.app.stage.y = 0;
      }
    }
  }
}
```

## React Integration

### React PIXI Component

```jsx
import { Stage, Container, Sprite, Text } from '@pixi/react';
import { usePlayroom, usePlayroomState } from '@PlayroomKit/react';

function PixiGameComponent() {
  const { players, isConnected } = usePlayroom();
  const [gameState, setGameState] = usePlayroomState('game', { phase: 'waiting' });
  
  if (!isConnected) {
    return <div>Connecting...</div>;
  }
  
  return (
    <Stage width={800} height={600} options={{ backgroundColor: 0x1099bb }}>
      <Container>
        {/* Background */}
        <Sprite
          image="/background.png"
          x={0}
          y={0}
          width={800}
          height={600}
        />
        
        {/* Players */}
        {players.map(player => (
          <PixiPlayerComponent key={player.id} player={player} />
        ))}
        
        {/* UI */}
        <Text
          text={`Players: ${players.length}`}
          x={10}
          y={10}
          style={{
            fontFamily: 'Arial',
            fontSize: 24,
            fill: 0xFFFFFF,
            stroke: 0x000000,
            strokeThickness: 2
          }}
        />
      </Container>
    </Stage>
  );
}

function PixiPlayerComponent({ player }) {
  const [position] = usePlayroomState(`players.${player.id}.position`, { x: 400, y: 300 });
  const [rotation] = usePlayroomState(`players.${player.id}.rotation`, 0);
  
  return (
    <Container x={position.x} y={position.y} rotation={rotation}>
      <Sprite
        image="/player.png"
        anchor={0.5}
        scale={0.5}
      />
      <Text
        text={player.name}
        anchor={0.5}
        y={-40}
        style={{
          fontFamily: 'Arial',
          fontSize: 16,
          fill: 0xFFFFFF,
          stroke: 0x000000,
          strokeThickness: 2
        }}
      />
    </Container>
  );
}
```

## Performance Optimization

### Object Pooling

```javascript
class ObjectPool {
  constructor(createFn, resetFn, initialSize = 10) {
    this.createFn = createFn;
    this.resetFn = resetFn;
    this.pool = [];
    
    // Pre-populate pool
    for (let i = 0; i < initialSize; i++) {
      this.pool.push(this.createFn());
    }
  }
  
  get() {
    if (this.pool.length > 0) {
      const obj = this.pool.pop();
      this.resetFn(obj);
      return obj;
    } else {
      return this.createFn();
    }
  }
  
  release(obj) {
    this.pool.push(obj);
  }
}

// Usage
const bulletPool = new ObjectPool(
  () => {
    const bullet = new PIXI.Graphics();
    bullet.beginFill(0xFFFF00);
    bullet.drawRect(-5, -2, 10, 4);
    bullet.endFill();
    return bullet;
  },
  (bullet) => {
    bullet.x = 0;
    bullet.y = 0;
    bullet.rotation = 0;
    bullet.visible = true;
    bullet.alpha = 1;
  },
  50 // Initial pool size
);
```

### Culling System

```javascript
class CullingSystem {
  constructor(app) {
    this.app = app;
    this.viewBounds = new PIXI.Rectangle(0, 0, app.screen.width, app.screen.height);
  }
  
  cullObjects(objects) {
    objects.forEach(obj => {
      const bounds = obj.getBounds();
      const visible = this.viewBounds.intersects(bounds);
      
      obj.visible = visible;
      obj.renderable = visible;
    });
  }
  
  updateViewBounds(camera) {
    this.viewBounds.x = camera.x - this.app.screen.width / 2;
    this.viewBounds.y = camera.y - this.app.screen.height / 2;
  }
}
```

## Best Practices

1. **Use Sprite Sheets**: Combine multiple images into sprite sheets for better performance
2. **Object Pooling**: Reuse objects instead of creating/destroying them
3. **Culling**: Don't render objects outside the viewport
4. **Batch Operations**: Group similar operations together
5. **Optimize Filters**: Use filters sparingly and cache when possible
6. **Texture Management**: Properly manage texture memory
7. **Network Optimization**: Only sync necessary data, use interpolation for smooth movement 