---
title: Introduction
description: You can build powerful, dynamic and easily-extendable games with React and PlayroomKit.
---



## usePlayroom

The main hook for accessing player and room information.

```jsx
import { usePlayroom } from '@PlayroomKit/react';

function GameLobby() {
    const { 
        isConnected, 
        players, 
        myPlayer, 
        room,
        isHost 
    } = usePlayroom();
    
    if (!isConnected) {
        return <div>Connecting to game...</div>;
    }
    
    return (
        <div>
            <h2>Room: {room.code}</h2>
            <p>Players: {players.length}/{room.maxPlayers}</p>
            {isHost && <button>Start Game</button>}
        </div>
    );
}
```

**Returns:**
- `isConnected` - Boolean indicating connection status
- `players` - Array of all players in the room
- `myPlayer` - Current player object
- `room` - Current room information
- `isHost` - Boolean indicating if current player is host

## usePlayroomState

Hook for managing shared game state with automatic synchronization.

```jsx
import { usePlayroomState } from '@PlayroomKit/react';

function GameBoard() {
    const [gameStarted, setGameStarted] = usePlayroomState('gameStarted', false);
    const [currentTurn, setCurrentTurn] = usePlayroomState('currentTurn', 0);
    const [score, setScore] = usePlayroomState('score', { red: 0, blue: 0 });
    
    return (
        <div>
            {!gameStarted ? (
                <button onClick={() => setGameStarted(true)}>
                    Start Game
                </button>
            ) : (
                <div>
                    <p>Turn: {currentTurn}</p>
                    <p>Score - Red: {score.red}, Blue: {score.blue}</p>
                    <button onClick={() => setScore({...score, red: score.red + 1})}>
                        Red Scores!
                    </button>
                </div>
            )}
        </div>
    );
}
```

**Parameters:**
- `key` - State key string
- `defaultValue` - Default value if state doesn't exist

**Returns:**
- `[value, setValue]` - Tuple similar to useState

## usePlayerState

Hook for managing individual player state.

```jsx
import { usePlayerState } from '@PlayroomKit/react';

function PlayerInfo({ playerId }) {
    const [ready, setReady] = usePlayerState(playerId, 'ready', false);
    const [character, setCharacter] = usePlayerState(playerId, 'character', null);
    
    return (
        <div>
            <p>Ready: {ready ? '‚úÖ' : '‚ùå'}</p>
            <p>Character: {character || 'None selected'}</p>
            <button onClick={() => setReady(!ready)}>
                Toggle Ready
            </button>
        </div>
    );
}
```

**Parameters:**
- `playerId` - Player ID
- `key` - State key string
- `defaultValue` - Default value

## useRpc

Hook for sending and receiving RPC calls.

```jsx
import { useRpc } from '@PlayroomKit/react';

function CombatSystem() {
    const sendAttack = useRpc('attack');
    const sendHeal = useRpc('heal');
    
    // Listen for incoming attacks
    useRpc('attack', (data, sender) => {
        console.log(`${sender.name} attacked for ${data.damage} damage!`);
        applyDamage(data.target, data.damage);
    });
    
    // Listen for heals
    useRpc('heal', (data, sender) => {
        console.log(`${sender.name} healed ${data.target}`);
        applyHeal(data.target, data.amount);
    });
    
    return (
        <div>
            <button onClick={() => sendAttack({ damage: 25, target: 'enemy' })}>
                Attack
            </button>
            <button onClick={() => sendHeal({ amount: 15, target: 'ally' })}>
                Heal
            </button>
        </div>
    );
}
```

**Usage:**
- `useRpc(method)` - Returns function to send RPC
- `useRpc(method, handler)` - Registers RPC handler

## usePlayerList

Hook for managing player list with filtering and sorting.

```jsx
import { usePlayerList } from '@PlayroomKit/react';

function PlayerList() {
    const { 
        players, 
        activePlayers, 
        readyPlayers,
        hostPlayer 
    } = usePlayerList();
    
    return (
        <div>
            <h3>All Players ({players.length})</h3>
            {players.map(player => (
                <div key={player.id}>
                    {player.name} 
                    {player.isHost && 'üëë'}
                    {player.getState('ready') && '‚úÖ'}
                </div>
            ))}
            
            <h3>Ready Players ({readyPlayers.length})</h3>
            {readyPlayers.map(player => (
                <div key={player.id}>{player.name}</div>
            ))}
        </div>
    );
}
```

## useGameTimer

Hook for managing game timers and countdowns.

```jsx
import { useGameTimer } from '@PlayroomKit/react';

function GameTimer() {
    const { 
        timeRemaining, 
        isRunning, 
        start, 
        pause, 
        reset 
    } = useGameTimer('gameTimer', 60); // 60 seconds
    
    return (
        <div>
            <h2>Time: {timeRemaining}s</h2>
            <button onClick={start} disabled={isRunning}>Start</button>
            <button onClick={pause} disabled={!isRunning}>Pause</button>
            <button onClick={reset}>Reset</button>
        </div>
    );
}
```

## useConnection

Hook for monitoring connection status and handling reconnections.

```jsx
import { useConnection } from '@PlayroomKit/react';

function ConnectionStatus() {
    const { 
        isConnected, 
        isReconnecting, 
        latency,
        reconnect 
    } = useConnection();
    
    if (isReconnecting) {
        return <div>Reconnecting...</div>;
    }
    
    return (
        <div>
            Status: {isConnected ? 'Connected' : 'Disconnected'}
            {isConnected && <span> | Latency: {latency}ms</span>}
            {!isConnected && (
                <button onClick={reconnect}>Reconnect</button>
            )}
        </div>
    );
}
```

## Custom Hook Example

Creating a custom hook for turn-based game logic:

```jsx
import { usePlayroomState, useRpc } from '@PlayroomKit/react';

function useTurnBasedGame(playerCount = 2) {
    const [currentTurn, setCurrentTurn] = usePlayroomState('currentTurn', 0);
    const [gameStarted, setGameStarted] = usePlayroomState('gameStarted', false);
    
    const nextTurn = useRpc('nextTurn');
    
    useRpc('nextTurn', () => {
        setCurrentTurn((turn) => (turn + 1) % playerCount);
    });
    
    const isMyTurn = (myPlayerId, players) => {
        return players[currentTurn]?.id === myPlayerId;
    };
    
    const startGame = () => {
        setGameStarted(true);
        setCurrentTurn(0);
    };
    
    const endTurn = () => {
        nextTurn();
    };
    
    return {
        currentTurn,
        gameStarted,
        isMyTurn,
        startGame,
        endTurn
    };
}
``` 