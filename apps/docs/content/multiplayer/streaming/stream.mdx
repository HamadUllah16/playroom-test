---
title: Streaming Features
description: Core streaming functionality and platform-agnostic features for multiplayer game streaming.
---


## Installation

```bash
npm install @PlayroomKit/client @PlayroomKit/streaming
```

For React projects:
```bash
npm install @PlayroomKit/react @PlayroomKit/streaming
```

## Basic Setup

### Streaming Manager

```javascript
import { Playroom } from '@PlayroomKit/client';
import { StreamingManager } from '@PlayroomKit/streaming';

class InteractiveStreamGame {
  constructor() {
    this.streaming = null;
    this.viewers = new Map();
    this.activePolls = new Map();
  }
  
  async init() {
    // Initialize PlayroomKit
    await Playroom.init('your-api-key');
    
    // Initialize Streaming Manager
    this.streaming = new StreamingManager({
      maxViewers: 1000,
      interactionCooldown: 5000, // 5 seconds
      moderationEnabled: true,
      platforms: ['twitch', 'youtube', 'discord']
    });
    
    await this.streaming.init();
    this.setupStreamingEvents();
  }
  
  setupStreamingEvents() {
    // Handle viewer interactions
    this.streaming.onViewerInteraction((viewer, interaction) => {
      this.handleViewerInteraction(viewer, interaction);
    });
    
    // Handle viewer join/leave
    this.streaming.onViewerJoin((viewer) => {
      this.addViewer(viewer);
    });
    
    this.streaming.onViewerLeave((viewer) => {
      this.removeViewer(viewer);
    });
    
    // Handle moderation events
    this.streaming.onModerationAction((action, target, moderator) => {
      this.handleModeration(action, target, moderator);
    });
  }
}
```

### React Streaming Integration

```jsx
import { useStreaming, usePlayroomState } from '@PlayroomKit/react';

function StreamingEnabledGame() {
  const [gameState, setGameState] = usePlayroomState('game', { phase: 'lobby' });
  const [viewers, setViewers] = usePlayroomState('viewers', {});
  
  const {
    isStreaming,
    viewerCount,
    activeInteractions,
    startStream,
    stopStream,
    sendStreamMessage,
    createPoll,
    enableViewerMode
  } = useStreaming({
    platforms: ['twitch', 'youtube'],
    maxViewers: 500,
    onViewerInteraction: (viewer, interaction) => {
      handleInteraction(viewer, interaction);
    }
  });
  
  const handleInteraction = (viewer, interaction) => {
    switch (interaction.type) {
      case 'spawn_item':
        spawnItemForViewer(viewer, interaction.data);
        break;
      case 'vote':
        registerVote(viewer, interaction.data);
        break;
      case 'cheer':
        triggerCheerEffect(viewer, interaction.data);
        break;
    }
  };
  
  return (
    <div className="streaming-game">
      <div className="game-area">
        <MultiplayerGameComponent />
        {isStreaming && <StreamOverlay />}
      </div>
      
      <div className="streaming-controls">
        <StreamingControlPanel 
          isStreaming={isStreaming}
          viewerCount={viewerCount}
          onStartStream={startStream}
          onStopStream={stopStream}
        />
      </div>
    </div>
  );
}
```

## Viewer Interactions

### Interactive Elements

```javascript
class ViewerInteractionSystem {
  constructor(streamingManager, gameInstance) {
    this.streaming = streamingManager;
    this.game = gameInstance;
    this.interactionTypes = this.setupInteractionTypes();
    this.cooldowns = new Map();
  }
  
  setupInteractionTypes() {
    return {
      spawn_item: {
        cooldown: 30000, // 30 seconds
        cost: 0, // Free
        handler: this.handleSpawnItem.bind(this)
      },
      vote_action: {
        cooldown: 10000, // 10 seconds
        cost: 0,
        handler: this.handleVoteAction.bind(this)
      },
      donate_effect: {
        cooldown: 60000, // 1 minute
        cost: 100, // Virtual currency
        handler: this.handleDonateEffect.bind(this)
      },
      boss_summon: {
        cooldown: 300000, // 5 minutes
        cost: 1000,
        handler: this.handleBossSummon.bind(this)
      }
    };
  }
  
  async processViewerInteraction(viewer, interaction) {
    const interactionType = this.interactionTypes[interaction.type];
    
    if (!interactionType) {
      console.warn(`Unknown interaction type: ${interaction.type}`);
      return;
    }
    
    // Check cooldown
    if (this.isOnCooldown(viewer.id, interaction.type)) {
      const remainingTime = this.getRemainingCooldown(viewer.id, interaction.type);
      this.streaming.sendMessageToViewer(viewer, 
        `Please wait ${Math.ceil(remainingTime / 1000)}s before using this action again.`
      );
      return;
    }
    
    // Check cost
    if (viewer.currency < interactionType.cost) {
      this.streaming.sendMessageToViewer(viewer,
        `You need ${interactionType.cost} coins for this action. You have ${viewer.currency}.`
      );
      return;
    }
    
    // Process interaction
    try {
      await interactionType.handler(viewer, interaction.data);
      
      // Apply cooldown
      this.setCooldown(viewer.id, interaction.type, interactionType.cooldown);
      
      // Deduct cost
      if (interactionType.cost > 0) {
        viewer.currency -= interactionType.cost;
        Playroom.setState(`viewers.${viewer.id}.currency`, viewer.currency);
      }
      
    } catch (error) {
      console.error('Failed to process viewer interaction:', error);
      this.streaming.sendMessageToViewer(viewer, 'Sorry, that action failed. Please try again later.');
    }
  }
  
  async handleSpawnItem(viewer, data) {
    const itemType = data.itemType || 'coin';
    const position = data.position || this.game.getRandomSpawnPosition();
    
    const item = this.game.spawnItem(itemType, position, {
      spawnedBy: viewer.id,
      spawnedByName: viewer.name
    });
    
    // Announce in stream
    this.streaming.broadcastMessage(
      `${viewer.name} spawned a ${itemType}! 🎁`
    );
    
    // Visual effect
    this.game.createSpawnEffect(position, viewer.color);
    
    return item;
  }
  
  async handleVoteAction(viewer, data) {
    const activePoll = Playroom.getState('activePoll');
    
    if (!activePoll) {
      throw new Error('No active poll');
    }
    
    // Register vote
    Playroom.setState(`polls.${activePoll.id}.votes.${viewer.id}`, {
      viewerId: viewer.id,
      viewerName: viewer.name,
      vote: data.choice,
      timestamp: Date.now()
    });
    
    this.streaming.sendMessageToViewer(viewer, 
      `Vote registered for "${data.choice}"! ✅`
    );
  }
  
  async handleDonateEffect(viewer, data) {
    const effect = data.effect || 'fireworks';
    const duration = data.duration || 5000;
    
    // Trigger visual effect
    this.game.createViewerEffect(effect, {
      duration: duration,
      intensity: data.intensity || 1.0,
      color: viewer.color,
      sponsoredBy: viewer.name
    });
    
    // Announce donation
    this.streaming.broadcastMessage(
      `${viewer.name} donated ${this.interactionTypes.donate_effect.cost} coins for ${effect} effect! ✨`
    );
  }
  
  async handleBossSummon(viewer, data) {
    const bossType = data.bossType || 'mega_boss';
    
    // Spawn boss
    const boss = this.game.spawnBoss(bossType, {
      summonedBy: viewer.id,
      summonedByName: viewer.name,
      difficulty: data.difficulty || 'normal'
    });
    
    // Epic announcement
    this.streaming.broadcastMessage(
      `🔥 ${viewer.name} summoned the ${bossType.toUpperCase()}! 🔥`
    );
    
    // Screen effect
    this.game.createEpicEffect('boss_summon');
  }
}
```

### Real-Time Polls

```javascript
class StreamPolls {
  constructor(streamingManager) {
    this.streaming = streamingManager;
    this.activePoll = null;
    this.pollHistory = [];
  }
  
  createPoll(question, options, duration = 60000, metadata = {}) {
    if (this.activePoll) {
      throw new Error('A poll is already active');
    }
    
    const pollId = `poll_${Date.now()}`;
    
    this.activePoll = {
      id: pollId,
      question: question,
      options: options,
      votes: {},
      startTime: Date.now(),
      duration: duration,
      metadata: metadata,
      totalVotes: 0
    };
    
    // Sync to game state
    Playroom.setState('activePoll', this.activePoll);
    
    // Announce poll
    this.streaming.broadcastMessage(
      `📊 NEW POLL: ${question}`
    );
    
    this.streaming.broadcastMessage(
      `Options: ${options.map((opt, i) => `${i + 1}. ${opt}`).join(' | ')}`
    );
    
    // Auto-end poll
    setTimeout(() => {
      if (this.activePoll && this.activePoll.id === pollId) {
        this.endPoll();
      }
    }, duration);
    
    return pollId;
  }
  
  endPoll() {
    if (!this.activePoll) return null;
    
    const results = this.calculateResults();
    
    // Announce results
    this.streaming.broadcastMessage('📊 POLL RESULTS:');
    results.forEach((result, index) => {
      const percentage = this.activePoll.totalVotes > 0 
        ? Math.round((result.votes / this.activePoll.totalVotes) * 100)
        : 0;
      
      this.streaming.broadcastMessage(
        `${index + 1}. ${result.option}: ${result.votes} votes (${percentage}%)`
      );
    });
    
    // Store in history
    this.pollHistory.push({
      ...this.activePoll,
      results: results,
      endTime: Date.now()
    });
    
    // Execute poll result if handler exists
    if (this.activePoll.metadata.onComplete) {
      this.activePoll.metadata.onComplete(results[0], results);
    }
    
    // Clear active poll
    const completedPoll = this.activePoll;
    this.activePoll = null;
    Playroom.setState('activePoll', null);
    
    return completedPoll;
  }
  
  calculateResults() {
    const voteCounts = {};
    this.activePoll.options.forEach(option => voteCounts[option] = 0);
    
    Object.values(this.activePoll.votes).forEach(vote => {
      if (voteCounts.hasOwnProperty(vote.vote)) {
        voteCounts[vote.vote]++;
      }
    });
    
    return this.activePoll.options.map(option => ({
      option: option,
      votes: voteCounts[option]
    })).sort((a, b) => b.votes - a.votes);
  }
  
  registerVote(viewerId, viewerName, choice) {
    if (!this.activePoll) {
      throw new Error('No active poll');
    }
    
    if (!this.activePoll.options.includes(choice)) {
      throw new Error('Invalid poll option');
    }
    
    const hadPreviousVote = this.activePoll.votes.hasOwnProperty(viewerId);
    
    this.activePoll.votes[viewerId] = {
      viewerId: viewerId,
      viewerName: viewerName,
      vote: choice,
      timestamp: Date.now()
    };
    
    if (!hadPreviousVote) {
      this.activePoll.totalVotes++;
    }
    
    // Update state
    Playroom.setState('activePoll', this.activePoll);
  }
}
```

## Stream Overlay

### Real-Time Game Information

```jsx
function StreamOverlay() {
  const [gameState] = usePlayroomState('game', {});
  const [players] = usePlayroomState('players', {});
  const [viewers] = usePlayroomState('viewers', {});
  const [activePoll] = usePlayroomState('activePoll', null);
  
  return (
    <div className="stream-overlay">
      {/* Top Bar */}
      <div className="overlay-top">
        <GameStatus phase={gameState.phase} />
        <PlayerCount 
          players={Object.keys(players).length}
          viewers={Object.keys(viewers).length}
        />
      </div>
      
      {/* Side Panel */}
      <div className="overlay-side">
        {activePoll && <PollDisplay poll={activePoll} />}
        <RecentInteractions />
        <TopViewers />
      </div>
      
      {/* Bottom Bar */}
      <div className="overlay-bottom">
        <InteractionCommands />
        <StreamerInfo />
      </div>
    </div>
  );
}

function PollDisplay({ poll }) {
  const [timeRemaining, setTimeRemaining] = useState(0);
  
  useEffect(() => {
    const updateTimer = () => {
      const remaining = Math.max(0, poll.startTime + poll.duration - Date.now());
      setTimeRemaining(remaining);
    };
    
    updateTimer();
    const interval = setInterval(updateTimer, 1000);
    return () => clearInterval(interval);
  }, [poll]);
  
  return (
    <div className="poll-overlay">
      <div className="poll-header">
        <h3>📊 Active Poll</h3>
        <span className="poll-timer">
          {Math.ceil(timeRemaining / 1000)}s
        </span>
      </div>
      
      <div className="poll-question">
        {poll.question}
      </div>
      
      <div className="poll-options">
        {poll.options.map((option, index) => (
          <div key={option} className="poll-option">
            <span className="option-number">{index + 1}</span>
            <span className="option-text">{option}</span>
          </div>
        ))}
      </div>
      
      <div className="poll-stats">
        Total Votes: {poll.totalVotes}
      </div>
    </div>
  );
}

function RecentInteractions() {
  const [interactions] = usePlayroomState('recentInteractions', []);
  
  return (
    <div className="recent-interactions">
      <h4>🎮 Recent Actions</h4>
      <div className="interactions-list">
        {interactions.slice(-5).map((interaction, index) => (
          <div key={index} className="interaction-item">
            <span className="viewer-name">{interaction.viewerName}</span>
            <span className="interaction-type">{interaction.type}</span>
            <span className="interaction-time">
              {formatTimeAgo(interaction.timestamp)}
            </span>
          </div>
        ))}
      </div>
    </div>
  );
}
```

## Analytics and Metrics

### Stream Analytics

```javascript
class StreamAnalytics {
  constructor(streamingManager) {
    this.streaming = streamingManager;
    this.analytics = {
      totalViewers: 0,
      peakViewers: 0,
      averageViewTime: 0,
      totalInteractions: 0,
      interactionsByType: {},
      pollParticipation: 0,
      revenueGenerated: 0,
      hourlyStats: []
    };
    
    this.sessionStart = Date.now();
    this.viewerSessions = new Map();
  }
  
  trackViewerJoin(viewer) {
    this.analytics.totalViewers++;
    this.analytics.peakViewers = Math.max(
      this.analytics.peakViewers, 
      this.streaming.getActiveViewerCount()
    );
    
    this.viewerSessions.set(viewer.id, {
      joinTime: Date.now(),
      interactions: 0,
      spent: 0
    });
    
    this.updateHourlyStats();
  }
  
  trackViewerLeave(viewer) {
    const session = this.viewerSessions.get(viewer.id);
    if (session) {
      const viewTime = Date.now() - session.joinTime;
      this.updateAverageViewTime(viewTime);
      this.viewerSessions.delete(viewer.id);
    }
  }
  
  trackInteraction(viewer, interaction) {
    this.analytics.totalInteractions++;
    
    const type = interaction.type;
    this.analytics.interactionsByType[type] = 
      (this.analytics.interactionsByType[type] || 0) + 1;
    
    const session = this.viewerSessions.get(viewer.id);
    if (session) {
      session.interactions++;
      if (interaction.cost) {
        session.spent += interaction.cost;
        this.analytics.revenueGenerated += interaction.cost;
      }
    }
    
    // Update real-time stats
    Playroom.setState('streamAnalytics', this.analytics);
  }
  
  trackPollParticipation(viewerId) {
    this.analytics.pollParticipation++;
    
    const session = this.viewerSessions.get(viewerId);
    if (session) {
      session.interactions++;
    }
  }
  
  updateAverageViewTime(newViewTime) {
    const currentAverage = this.analytics.averageViewTime;
    const totalSessions = this.analytics.totalViewers;
    
    this.analytics.averageViewTime = 
      ((currentAverage * (totalSessions - 1)) + newViewTime) / totalSessions;
  }
  
  updateHourlyStats() {
    const currentHour = new Date().getHours();
    const today = new Date().toDateString();
    
    let hourlyEntry = this.analytics.hourlyStats.find(
      entry => entry.hour === currentHour && entry.date === today
    );
    
    if (!hourlyEntry) {
      hourlyEntry = {
        hour: currentHour,
        date: today,
        viewers: 0,
        interactions: 0,
        revenue: 0
      };
      this.analytics.hourlyStats.push(hourlyEntry);
    }
    
    hourlyEntry.viewers = this.streaming.getActiveViewerCount();
    hourlyEntry.interactions = this.analytics.totalInteractions;
    hourlyEntry.revenue = this.analytics.revenueGenerated;
  }
  
  generateReport() {
    const sessionDuration = Date.now() - this.sessionStart;
    
    return {
      sessionDuration: sessionDuration,
      totalViewers: this.analytics.totalViewers,
      peakViewers: this.analytics.peakViewers,
      averageViewTime: this.analytics.averageViewTime,
      totalInteractions: this.analytics.totalInteractions,
      interactionRate: this.analytics.totalInteractions / this.analytics.totalViewers,
      pollParticipation: this.analytics.pollParticipation,
      revenueGenerated: this.analytics.revenueGenerated,
      topInteractions: this.getTopInteractions(),
      engagementScore: this.calculateEngagementScore(),
      hourlyBreakdown: this.analytics.hourlyStats
    };
  }
  
  getTopInteractions() {
    return Object.entries(this.analytics.interactionsByType)
      .sort(([,a], [,b]) => b - a)
      .slice(0, 5);
  }
  
  calculateEngagementScore() {
    const interactionRate = this.analytics.totalInteractions / Math.max(1, this.analytics.totalViewers);
    const pollRate = this.analytics.pollParticipation / Math.max(1, this.analytics.totalViewers);
    const retentionRate = this.analytics.averageViewTime / (30 * 60 * 1000); // 30 min baseline
    
    return Math.min(100, (interactionRate * 30 + pollRate * 40 + retentionRate * 30));
  }
}
```

## Moderation System

### Automated Moderation

```javascript
class StreamModeration {
  constructor(streamingManager) {
    this.streaming = streamingManager;
    this.bannedViewers = new Set();
    this.mutedViewers = new Map(); // viewerId -> muteUntil timestamp
    this.spamDetection = new Map(); // viewerId -> interaction count
    this.moderators = new Set();
    
    this.rules = {
      maxInteractionsPerMinute: 10,
      spamThreshold: 5,
      toxicityThreshold: 0.8,
      autoMuteDuration: 300000 // 5 minutes
    };
  }
  
  addModerator(userId) {
    this.moderators.add(userId);
    Playroom.setState(`moderators.${userId}`, {
      addedAt: Date.now(),
      permissions: ['mute', 'kick', 'poll_control']
    });
  }
  
  isModerator(userId) {
    return this.moderators.has(userId);
  }
  
  async checkInteraction(viewer, interaction) {
    // Check if banned
    if (this.bannedViewers.has(viewer.id)) {
      throw new Error('User is banned');
    }
    
    // Check if muted
    const muteUntil = this.mutedViewers.get(viewer.id);
    if (muteUntil && Date.now() < muteUntil) {
      throw new Error('User is muted');
    }
    
    // Spam detection
    if (this.detectSpam(viewer.id)) {
      await this.autoMute(viewer.id, this.rules.autoMuteDuration);
      throw new Error('Spam detected - auto muted');
    }
    
    // Content filtering (if applicable)
    if (interaction.message && await this.detectToxicity(interaction.message)) {
      await this.autoMute(viewer.id, this.rules.autoMuteDuration);
      throw new Error('Inappropriate content detected');
    }
    
    return true;
  }
  
  detectSpam(viewerId) {
    const now = Date.now();
    const oneMinuteAgo = now - 60000;
    
    if (!this.spamDetection.has(viewerId)) {
      this.spamDetection.set(viewerId, []);
    }
    
    const interactions = this.spamDetection.get(viewerId);
    
    // Remove old interactions
    const recentInteractions = interactions.filter(time => time > oneMinuteAgo);
    this.spamDetection.set(viewerId, recentInteractions);
    
    // Add current interaction
    recentInteractions.push(now);
    
    return recentInteractions.length > this.rules.maxInteractionsPerMinute;
  }
  
  async detectToxicity(message) {
    // Simple word filter (in production, use ML-based toxicity detection)
    const toxicWords = ['spam', 'hate', 'toxic']; // Simplified example
    const lowerMessage = message.toLowerCase();
    
    return toxicWords.some(word => lowerMessage.includes(word));
  }
  
  async muteViewer(viewerId, duration, moderatorId = null) {
    const muteUntil = Date.now() + duration;
    this.mutedViewers.set(viewerId, muteUntil);
    
    Playroom.setState(`moderation.mutes.${viewerId}`, {
      mutedAt: Date.now(),
      muteUntil: muteUntil,
      moderator: moderatorId,
      reason: 'Manual mute'
    });
    
    this.streaming.sendMessageToViewer(
      { id: viewerId },
      `You have been muted for ${Math.ceil(duration / 60000)} minutes.`
    );
  }
  
  async autoMute(viewerId, duration) {
    await this.muteViewer(viewerId, duration, 'system');
    
    this.streaming.broadcastMessage(
      `User ${viewerId} was automatically muted for ${Math.ceil(duration / 60000)} minutes.`
    );
  }
  
  async banViewer(viewerId, reason, moderatorId) {
    this.bannedViewers.add(viewerId);
    
    Playroom.setState(`moderation.bans.${viewerId}`, {
      bannedAt: Date.now(),
      reason: reason,
      moderator: moderatorId
    });
    
    // Remove from active viewers
    this.streaming.removeViewer(viewerId);
    
    this.streaming.broadcastMessage(
      `User ${viewerId} has been banned.`
    );
  }
  
  handleModerationCommand(moderator, command, target, reason = '') {
    if (!this.isModerator(moderator.id)) {
      throw new Error('Insufficient permissions');
    }
    
    switch (command) {
      case 'mute':
        this.muteViewer(target, 300000, moderator.id); // 5 minutes
        break;
      case 'unmute':
        this.mutedViewers.delete(target);
        Playroom.setState(`moderation.mutes.${target}`, null);
        break;
      case 'ban':
        this.banViewer(target, reason, moderator.id);
        break;
      case 'unban':
        this.bannedViewers.delete(target);
        Playroom.setState(`moderation.bans.${target}`, null);
        break;
      default:
        throw new Error('Unknown moderation command');
    }
  }
}
```

## Best Practices

### Performance Optimization

```javascript
class StreamOptimization {
  constructor() {
    this.messageQueue = [];
    this.interactionBuffer = [];
    this.batchSize = 10;
    this.batchInterval = 100; // ms
  }
  
  // Batch viewer interactions to reduce server load
  queueInteraction(viewer, interaction) {
    this.interactionBuffer.push({ viewer, interaction, timestamp: Date.now() });
    
    if (this.interactionBuffer.length >= this.batchSize) {
      this.processBatch();
    }
  }
  
  processBatch() {
    if (this.interactionBuffer.length === 0) return;
    
    const batch = this.interactionBuffer.splice(0, this.batchSize);
    
    // Process batch
    Playroom.setState('interactionBatch', {
      interactions: batch,
      timestamp: Date.now()
    });
  }
  
  startBatchProcessor() {
    setInterval(() => {
      if (this.interactionBuffer.length > 0) {
        this.processBatch();
      }
    }, this.batchInterval);
  }
  
  // Optimize message broadcasting
  broadcastMessage(message, priority = 'normal') {
    const messageData = {
      message: message,
      timestamp: Date.now(),
      priority: priority
    };
    
    if (priority === 'high') {
      // Send immediately
      this.sendImmediate(messageData);
    } else {
      // Queue for batch sending
      this.messageQueue.push(messageData);
    }
  }
  
  sendImmediate(messageData) {
    Playroom.setState('streamMessages.immediate', messageData);
  }
}
```

### Error Handling

```javascript
// Graceful error handling for streaming
function handleStreamingError(error, context) {
  console.error(`Streaming error in ${context}:`, error);
  
  switch (error.type) {
    case 'VIEWER_LIMIT_EXCEEDED':
      // Queue new viewers
      queueViewer(error.viewer);
      break;
      
    case 'INTERACTION_FAILED':
      // Retry with exponential backoff
      retryInteraction(error.interaction, error.attempts || 0);
      break;
      
    case 'PLATFORM_DISCONNECTED':
      // Attempt reconnection
      attemptReconnection(error.platform);
      break;
      
    default:
      // Log and continue
      logError(error, context);
  }
}

function retryInteraction(interaction, attempts) {
  if (attempts >= 3) {
    console.error('Max retry attempts reached for interaction:', interaction);
    return;
  }
  
  const delay = Math.pow(2, attempts) * 1000; // Exponential backoff
  
  setTimeout(() => {
    try {
      processInteraction(interaction);
    } catch (error) {
      retryInteraction(interaction, attempts + 1);
    }
  }, delay);
}
```

## Troubleshooting

### Common Issues

**High latency in viewer interactions:**
```javascript
// Check interaction processing queue
console.log('Interaction queue size:', interactionBuffer.length);

// Optimize batch processing
if (interactionBuffer.length > 50) {
  // Increase batch size temporarily
  batchSize = 20;
}
```

**Viewer synchronization issues:**
```javascript
// Implement heartbeat system
setInterval(() => {
  streaming.sendHeartbeat();
}, 30000);

// Handle connection recovery
streaming.onConnectionLost(() => {
  console.log('Connection lost, attempting recovery...');
  streaming.reconnect();
});
```

**Memory leaks from viewer data:**
```javascript
// Clean up inactive viewers
setInterval(() => {
  const now = Date.now();
  const inactiveThreshold = 5 * 60 * 1000; // 5 minutes
  
  viewers.forEach((viewer, id) => {
    if (now - viewer.lastActive > inactiveThreshold) {
      removeViewer(id);
    }
  });
}, 60000); // Check every minute
```
