---
title: Twitch Integration
description: Integrate your multiplayer games with Twitch for interactive streaming experiences.
---

# Twitch Integration

PlayroomKit provides seamless Twitch integration, allowing streamers to create interactive multiplayer experiences where viewers can participate directly in the game.

## Installation

```bash
npm install @PlayroomKit/client @PlayroomKit/twitch
```

For React projects:
```bash
npm install @PlayroomKit/react @PlayroomKit/twitch
```

## Basic Setup

### Twitch Extension Setup

```javascript
import { Playroom } from '@PlayroomKit/client';
import { TwitchExtension } from '@PlayroomKit/twitch';

class TwitchMultiplayerGame {
  constructor() {
    this.twitchExt = null;
    this.viewerParticipants = new Map();
  }
  
  async init() {
    // Initialize PlayroomKit
    await Playroom.init('your-api-key');
    
    // Initialize Twitch Extension
    this.twitchExt = new TwitchExtension({
      clientId: 'your-twitch-client-id',
      version: '1.0.0',
      maxViewerParticipants: 100
    });
    
    await this.twitchExt.init();
    this.setupTwitchEvents();
  }
  
  setupTwitchEvents() {
    // Handle viewer interactions
    this.twitchExt.onViewerInteraction((viewer, action) => {
      this.handleViewerAction(viewer, action);
    });
    
    // Handle chat commands
    this.twitchExt.onChatCommand((user, command, args) => {
      this.handleChatCommand(user, command, args);
    });
    
    // Handle viewer join/leave
    this.twitchExt.onViewerJoin((viewer) => {
      this.addViewerParticipant(viewer);
    });
    
    this.twitchExt.onViewerLeave((viewer) => {
      this.removeViewerParticipant(viewer);
    });
  }
}
```

### React Integration

```jsx
import { useTwitch, usePlayroomState } from '@PlayroomKit/react';

function TwitchInteractiveGame() {
  const [gameState, setGameState] = usePlayroomState('game', { phase: 'lobby' });
  
  const {
    isExtensionActive,
    viewerCount,
    chatMessages,
    sendChatMessage,
    startViewerPoll,
    getChannelInfo
  } = useTwitch({
    clientId: 'your-twitch-client-id',
    onViewerInteraction: (viewer, action) => {
      handleViewerAction(viewer, action);
    }
  });
  
  const handleViewerAction = (viewer, action) => {
    switch (action.type) {
      case 'vote':
        handleViewerVote(viewer, action.data);
        break;
      case 'spawn_item':
        handleSpawnItem(viewer, action.data);
        break;
      case 'cheer':
        handleCheer(viewer, action.data);
        break;
    }
  };
  
  return (
    <div className="twitch-game">
      <div className="game-area">
        <MultiplayerGameComponent />
      </div>
      
      <div className="twitch-overlay">
        <ViewerCount count={viewerCount} />
        <ChatOverlay messages={chatMessages} />
        <ViewerInteractionPanel />
      </div>
    </div>
  );
}
```

## Viewer Participation

### Chat Commands

```javascript
class TwitchChatCommands {
  constructor(twitchExt, gameInstance) {
    this.twitch = twitchExt;
    this.game = gameInstance;
    this.commands = this.setupCommands();
  }
  
  setupCommands() {
    return {
      '!join': this.handleJoinCommand.bind(this),
      '!vote': this.handleVoteCommand.bind(this),
      '!spawn': this.handleSpawnCommand.bind(this),
      '!help': this.handleHelpCommand.bind(this),
      '!stats': this.handleStatsCommand.bind(this)
    };
  }
  
  handleChatCommand(user, command, args) {
    const commandHandler = this.commands[command.toLowerCase()];
    
    if (commandHandler) {
      commandHandler(user, args);
    }
  }
  
  handleJoinCommand(user, args) {
    // Allow viewer to join as spectator or participant
    const participantCount = Playroom.getState('viewerParticipants.count') || 0;
    
    if (participantCount < 50) {
      Playroom.setState(`viewerParticipants.${user.id}`, {
        username: user.username,
        joinedAt: Date.now(),
        role: 'participant'
      });
      
      this.twitch.sendChatMessage(`@${user.username} joined the game! 🎮`);
    } else {
      this.twitch.sendChatMessage(`@${user.username} the game is full, but you can still vote and interact! 👥`);
    }
  }
  
  handleVoteCommand(user, args) {
    const currentPoll = Playroom.getState('activePoll');
    
    if (!currentPoll) {
      this.twitch.sendChatMessage(`@${user.username} no active poll right now!`);
      return;
    }
    
    const vote = args[0];
    if (currentPoll.options.includes(vote)) {
      Playroom.setState(`polls.${currentPoll.id}.votes.${user.id}`, {
        username: user.username,
        vote: vote,
        timestamp: Date.now()
      });
      
      this.twitch.sendChatMessage(`@${user.username} voted for ${vote}! ✅`);
    }
  }
  
  handleSpawnCommand(user, args) {
    // Allow viewers to spawn items (with cooldown)
    const lastSpawn = Playroom.getState(`viewerCooldowns.${user.id}.lastSpawn`) || 0;
    const cooldownTime = 30000; // 30 seconds
    
    if (Date.now() - lastSpawn < cooldownTime) {
      const remainingTime = Math.ceil((cooldownTime - (Date.now() - lastSpawn)) / 1000);
      this.twitch.sendChatMessage(`@${user.username} please wait ${remainingTime}s before spawning again!`);
      return;
    }
    
    const itemType = args[0] || 'coin';
    this.game.spawnViewerItem(user, itemType);
    
    Playroom.setState(`viewerCooldowns.${user.id}.lastSpawn`, Date.now());
  }
}
```

### Interactive Polls

```javascript
class ViewerPolls {
  constructor(twitchExt) {
    this.twitch = twitchExt;
    this.activePoll = null;
  }
  
  startPoll(question, options, duration = 30000) {
    const pollId = `poll_${Date.now()}`;
    
    this.activePoll = {
      id: pollId,
      question: question,
      options: options,
      startTime: Date.now(),
      duration: duration,
      votes: {}
    };
    
    Playroom.setState('activePoll', this.activePoll);
    
    // Announce poll in chat
    this.twitch.sendChatMessage(`📊 POLL: ${question}`);
    this.twitch.sendChatMessage(`Vote with: ${options.map(opt => `!vote ${opt}`).join(' | ')}`);
    
    // Auto-end poll
    setTimeout(() => {
      this.endPoll();
    }, duration);
    
    return pollId;
  }
  
  endPoll() {
    if (!this.activePoll) return;
    
    const votes = Playroom.getState(`polls.${this.activePoll.id}.votes`) || {};
    const results = this.calculateResults(votes, this.activePoll.options);
    
    // Announce results
    this.twitch.sendChatMessage(`📊 Poll Results:`);
    results.forEach(result => {
      this.twitch.sendChatMessage(`${result.option}: ${result.votes} votes (${result.percentage}%)`);
    });
    
    // Execute poll result
    this.executePollResult(results[0]); // Winner
    
    Playroom.setState('activePoll', null);
    this.activePoll = null;
  }
  
  calculateResults(votes, options) {
    const voteCounts = {};
    options.forEach(option => voteCounts[option] = 0);
    
    Object.values(votes).forEach(vote => {
      if (voteCounts.hasOwnProperty(vote.vote)) {
        voteCounts[vote.vote]++;
      }
    });
    
    const totalVotes = Object.values(voteCounts).reduce((a, b) => a + b, 0);
    
    return options.map(option => ({
      option: option,
      votes: voteCounts[option],
      percentage: totalVotes > 0 ? Math.round((voteCounts[option] / totalVotes) * 100) : 0
    })).sort((a, b) => b.votes - a.votes);
  }
  
  executePollResult(winner) {
    // Execute the winning poll option
    switch (winner.option) {
      case 'spawn_boss':
        this.game.spawnBoss();
        break;
      case 'double_speed':
        this.game.setSpeedMultiplier(2, 30000);
        break;
      case 'rain_coins':
        this.game.spawnCoinRain();
        break;
    }
  }
}
```

## Bits and Subscriptions

### Bits Integration

```javascript
class TwitchBitsIntegration {
  constructor(twitchExt, gameInstance) {
    this.twitch = twitchExt;
    this.game = gameInstance;
    this.setupBitsHandlers();
  }
  
  setupBitsHandlers() {
    this.twitch.onBitsTransaction((transaction) => {
      this.handleBitsCheer(transaction);
    });
  }
  
  handleBitsCheer(transaction) {
    const { user, bits, message } = transaction;
    
    // Different effects based on bits amount
    if (bits >= 1000) {
      this.triggerMegaEffect(user, bits);
    } else if (bits >= 500) {
      this.triggerLargeEffect(user, bits);
    } else if (bits >= 100) {
      this.triggerMediumEffect(user, bits);
    } else {
      this.triggerSmallEffect(user, bits);
    }
    
    // Thank the user
    this.twitch.sendChatMessage(`Thanks @${user.username} for the ${bits} bits! 💎✨`);
    
    // Log the transaction
    Playroom.setState(`bitsLog.${Date.now()}`, {
      username: user.username,
      bits: bits,
      message: message,
      timestamp: Date.now()
    });
  }
  
  triggerMegaEffect(user, bits) {
    // Spawn special boss or major game event
    this.game.spawnSpecialBoss(user.username);
    this.game.createExplosionEffect();
    this.twitch.sendChatMessage(`💥 ${user.username} summoned a MEGA BOSS with ${bits} bits!`);
  }
  
  triggerLargeEffect(user, bits) {
    // Spawn multiple power-ups
    for (let i = 0; i < 5; i++) {
      this.game.spawnPowerUp();
    }
    this.twitch.sendChatMessage(`⚡ ${user.username} spawned 5 power-ups!`);
  }
  
  triggerMediumEffect(user, bits) {
    // Change game environment
    this.game.changeWeather('storm', 15000);
    this.twitch.sendChatMessage(`⛈️ ${user.username} summoned a storm!`);
  }
  
  triggerSmallEffect(user, bits) {
    // Spawn coins or small items
    this.game.spawnCoins(bits / 10);
    this.twitch.sendChatMessage(`🪙 ${user.username} made it rain coins!`);
  }
}
```

### Subscription Events

```javascript
class TwitchSubscriptionEvents {
  constructor(twitchExt, gameInstance) {
    this.twitch = twitchExt;
    this.game = gameInstance;
    this.setupSubHandlers();
  }
  
  setupSubHandlers() {
    this.twitch.onSubscription((sub) => {
      this.handleNewSubscription(sub);
    });
    
    this.twitch.onGiftSubscription((gift) => {
      this.handleGiftSubscription(gift);
    });
    
    this.twitch.onResubscription((resub) => {
      this.handleResubscription(resub);
    });
  }
  
  handleNewSubscription(sub) {
    const { user, tier, message } = sub;
    
    // Spawn subscriber-exclusive content
    this.game.spawnSubscriberItem(user.username, tier);
    
    // Visual celebration
    this.game.createCelebrationEffect(user.username);
    
    // Chat announcement
    this.twitch.sendChatMessage(`🎉 Welcome to the squad, @${user.username}! Thanks for subscribing! 💜`);
    
    // Add subscriber perks
    this.addSubscriberPerks(user, tier);
  }
  
  handleGiftSubscription(gift) {
    const { gifter, recipient, tier, totalGifts } = gift;
    
    // Special effects for gift subs
    this.game.createGiftSubEffect(gifter.username, totalGifts);
    
    this.twitch.sendChatMessage(`🎁 ${gifter.username} gifted a sub to ${recipient.username}! Total gifts: ${totalGifts}`);
    
    // Bonus content for generous gifters
    if (totalGifts >= 5) {
      this.game.spawnBonusContent();
    }
  }
  
  addSubscriberPerks(user, tier) {
    const perks = {
      tier1: {
        spawnCooldown: 0.8, // 20% faster
        specialCommands: ['!sub_spawn', '!sub_vote'],
        chatColor: '#9146FF'
      },
      tier2: {
        spawnCooldown: 0.6, // 40% faster
        specialCommands: ['!sub_spawn', '!sub_vote', '!sub_effect'],
        chatColor: '#F1618C'
      },
      tier3: {
        spawnCooldown: 0.4, // 60% faster
        specialCommands: ['!sub_spawn', '!sub_vote', '!sub_effect', '!sub_boss'],
        chatColor: '#FFD700'
      }
    };
    
    Playroom.setState(`subscribers.${user.id}`, {
      username: user.username,
      tier: tier,
      perks: perks[tier],
      subscribedAt: Date.now()
    });
  }
}
```

## Stream Overlay

### Game Information Overlay

```jsx
function TwitchStreamOverlay() {
  const [gameState] = usePlayroomState('game', {});
  const [players] = usePlayroomState('players', {});
  const [viewerStats] = usePlayroomState('viewerStats', {});
  
  return (
    <div className="stream-overlay">
      <div className="top-bar">
        <div className="game-info">
          <h3>PlayroomKit Live</h3>
          <span>Phase: {gameState.phase}</span>
        </div>
        
        <div className="viewer-info">
          <span>👥 {Object.keys(players).length} Players</span>
          <span>👀 {viewerStats.participating || 0} Participating</span>
        </div>
      </div>
      
      <div className="side-panel">
        <ActivePollDisplay />
        <RecentBitsDisplay />
        <TopViewerParticipants />
      </div>
      
      <div className="bottom-bar">
        <div className="commands-help">
          <span>Commands: !join !vote !spawn !help</span>
        </div>
      </div>
    </div>
  );
}

function ActivePollDisplay() {
  const [activePoll] = usePlayroomState('activePoll', null);
  
  if (!activePoll) return null;
  
  return (
    <div className="active-poll">
      <h4>📊 Active Poll</h4>
      <p>{activePoll.question}</p>
      <div className="poll-options">
        {activePoll.options.map(option => (
          <div key={option} className="poll-option">
            !vote {option}
          </div>
        ))}
      </div>
    </div>
  );
}
```

## Analytics and Insights

### Viewer Engagement Tracking

```javascript
class TwitchAnalytics {
  constructor(twitchExt) {
    this.twitch = twitchExt;
    this.analytics = {
      viewerInteractions: 0,
      chatCommands: 0,
      bitsTotal: 0,
      pollParticipation: 0,
      peakViewers: 0
    };
  }
  
  trackInteraction(type, data) {
    this.analytics.viewerInteractions++;
    
    // Update specific metrics
    switch (type) {
      case 'chat_command':
        this.analytics.chatCommands++;
        break;
      case 'bits_cheer':
        this.analytics.bitsTotal += data.bits;
        break;
      case 'poll_vote':
        this.analytics.pollParticipation++;
        break;
    }
    
    // Update peak viewers
    const currentViewers = this.twitch.getViewerCount();
    if (currentViewers > this.analytics.peakViewers) {
      this.analytics.peakViewers = currentViewers;
    }
    
    // Sync analytics to game state
    Playroom.setState('streamAnalytics', this.analytics);
  }
  
  generateReport() {
    return {
      ...this.analytics,
      engagementRate: this.calculateEngagementRate(),
      averageViewers: this.calculateAverageViewers(),
      topCommands: this.getTopCommands()
    };
  }
  
  calculateEngagementRate() {
    const totalViewers = this.analytics.peakViewers;
    const interactiveViewers = this.analytics.viewerInteractions;
    
    return totalViewers > 0 ? (interactiveViewers / totalViewers) * 100 : 0;
  }
}
```

## Best Practices

### Performance Optimization

```javascript
class TwitchOptimization {
  constructor() {
    this.messageQueue = [];
    this.rateLimiter = new Map();
  }
  
  // Rate limit chat messages
  sendChatMessage(message, user = null) {
    const now = Date.now();
    const key = user ? `user_${user.id}` : 'system';
    
    const lastMessage = this.rateLimiter.get(key) || 0;
    const minInterval = user ? 1000 : 100; // 1s for users, 100ms for system
    
    if (now - lastMessage < minInterval) {
      this.messageQueue.push({ message, user, timestamp: now });
      return;
    }
    
    this.twitch.sendChatMessage(message);
    this.rateLimiter.set(key, now);
  }
  
  // Process queued messages
  processMessageQueue() {
    const now = Date.now();
    const readyMessages = this.messageQueue.filter(msg => 
      now - msg.timestamp >= 1000
    );
    
    readyMessages.forEach(msg => {
      this.sendChatMessage(msg.message, msg.user);
    });
    
    this.messageQueue = this.messageQueue.filter(msg => 
      !readyMessages.includes(msg)
    );
  }
}
```

### Security Considerations

```javascript
// Validate viewer actions
function validateViewerAction(user, action) {
  // Check if user is banned
  if (isUserBanned(user.id)) {
    return false;
  }
  
  // Check action rate limits
  if (exceedsRateLimit(user.id, action.type)) {
    return false;
  }
  
  // Validate action parameters
  if (!isValidAction(action)) {
    return false;
  }
  
  return true;
}

// Sanitize chat commands
function sanitizeCommand(command, args) {
  const allowedCommands = ['!join', '!vote', '!spawn', '!help', '!stats'];
  
  if (!allowedCommands.includes(command)) {
    return null;
  }
  
  // Sanitize arguments
  const cleanArgs = args.map(arg => 
    arg.replace(/[<>&"']/g, '') // Remove potentially dangerous characters
  );
  
  return { command, args: cleanArgs };
}
```

## Troubleshooting

### Common Issues

**Extension not loading:**
```javascript
// Check Twitch extension status
if (!window.Twitch || !window.Twitch.ext) {
  console.error('Twitch extension not available');
  // Fallback to regular game mode
}

// Verify authentication
window.Twitch.ext.onAuthorized((auth) => {
  console.log('Twitch auth successful:', auth);
});
```

**Chat commands not working:**
```javascript
// Debug chat message handling
this.twitch.onChatMessage((message) => {
  console.log('Chat message received:', message);
  
  if (message.startsWith('!')) {
    console.log('Command detected:', message);
  }
});
```

**Viewer synchronization issues:**
```javascript
// Implement reconnection logic
this.twitch.onConnectionLost(() => {
  console.log('Twitch connection lost, attempting reconnection...');
  
  setTimeout(() => {
    this.twitch.reconnect();
  }, 5000);
});
```
