---
title: Types of Multiplayer Games
description: Explore different types of multiplayer games you can build with PlayroomKit and best practices for each.
---

# Types of Multiplayer Games

PlayroomKit supports various types of multiplayer games, each with unique requirements and design considerations. This guide covers the main categories and how to implement them effectively.

## Turn-Based Games

Turn-based games are perfect for strategic gameplay where players take turns to make moves.

### Characteristics
- **Sequential Gameplay**: Players take turns in a defined order
- **Low Network Requirements**: Less real-time synchronization needed
- **Strategic Depth**: Time to think and plan moves
- **Async-Friendly**: Players can join/leave between turns

### Implementation

```javascript
import { Playroom } from '@PlayroomKit/client';

class TurnBasedGame {
  constructor() {
    this.turnOrder = [];
    this.currentTurnIndex = 0;
    this.turnTimer = 30; // 30 seconds per turn
  }
  
  async initGame() {
    await Playroom.init('your-api-key');
    
    // Set up turn order
    const players = Playroom.getPlayers();
    this.turnOrder = players.map(p => p.id);
    
    Playroom.setState('game', {
      phase: 'playing',
      turnOrder: this.turnOrder,
      currentTurn: this.turnOrder[0],
      turnTimer: this.turnTimer,
      turnStartTime: Date.now()
    });
    
    this.startTurnTimer();
  }
  
  makeMove(move) {
    const currentPlayer = Playroom.getMyPlayer();
    const gameState = Playroom.getState('game');
    
    // Validate it's player's turn
    if (gameState.currentTurn !== currentPlayer.id) {
      console.warn('Not your turn!');
      return;
    }
    
    // Process move
    Playroom.rpc('playerMove', {
      playerId: currentPlayer.id,
      move: move,
      timestamp: Date.now()
    });
    
    this.nextTurn();
  }
  
  nextTurn() {
    const gameState = Playroom.getState('game');
    const nextIndex = (gameState.turnOrder.indexOf(gameState.currentTurn) + 1) % gameState.turnOrder.length;
    
    Playroom.setState('game.currentTurn', gameState.turnOrder[nextIndex]);
    Playroom.setState('game.turnStartTime', Date.now());
    
    this.startTurnTimer();
  }
  
  startTurnTimer() {
    setTimeout(() => {
      const gameState = Playroom.getState('game');
      if (Date.now() - gameState.turnStartTime >= this.turnTimer * 1000) {
        this.nextTurn(); // Auto-skip turn
      }
    }, this.turnTimer * 1000);
  }
}
```

### Examples
- Chess, Checkers
- Tic-Tac-Toe
- Card games (Poker, UNO)
- Board games (Monopoly, Scrabble)

## Real-Time Games

Real-time games require continuous synchronization and immediate response to player actions.

### Characteristics
- **Continuous Action**: Players act simultaneously
- **High Network Requirements**: Frequent state updates
- **Immediate Feedback**: Instant response to inputs
- **Synchronization Critical**: All players must see the same state

### Implementation

```javascript
class RealTimeGame {
  constructor() {
    this.gameLoop = null;
    this.updateRate = 60; // 60 FPS
    this.lastUpdate = Date.now();
  }
  
  async initGame() {
    await Playroom.init('your-api-key');
    
    // Initialize game state
    Playroom.setState('game', {
      phase: 'playing',
      entities: {},
      timestamp: Date.now()
    });
    
    // Start game loop
    this.startGameLoop();
    
    // Handle player input
    this.setupInputHandlers();
  }
  
  startGameLoop() {
    this.gameLoop = setInterval(() => {
      this.update();
    }, 1000 / this.updateRate);
  }
  
  update() {
    const now = Date.now();
    const deltaTime = (now - this.lastUpdate) / 1000;
    
    // Update game logic
    this.updateEntities(deltaTime);
    this.checkCollisions();
    this.syncCriticalState();
    
    this.lastUpdate = now;
  }
  
  setupInputHandlers() {
    // Continuous input handling
    document.addEventListener('keydown', (e) => {
      this.handleInput(e.key, true);
    });
    
    document.addEventListener('keyup', (e) => {
      this.handleInput(e.key, false);
    });
  }
  
  handleInput(key, pressed) {
    const player = Playroom.getMyPlayer();
    const currentInput = Playroom.getState(`players.${player.id}.input`) || {};
    
    // Update input state
    Playroom.setState(`players.${player.id}.input`, {
      ...currentInput,
      [key]: pressed,
      timestamp: Date.now()
    });
  }
  
  syncCriticalState() {
    // Only sync important changes to reduce network traffic
    const criticalState = this.getCriticalGameState();
    Playroom.setState('game.critical', criticalState);
  }
}
```

### Examples
- Racing games
- First-person shooters
- Fighting games
- Sports simulations

## Cooperative Games

Players work together towards a common goal.

### Characteristics
- **Shared Objectives**: All players work towards the same goal
- **Complementary Roles**: Different player abilities/roles
- **Communication Important**: Coordination is key
- **Shared Success/Failure**: Team wins or loses together

### Implementation

```javascript
class CooperativeGame {
  constructor() {
    this.roles = ['tank', 'healer', 'damage', 'support'];
    this.objectives = [];
  }
  
  async initGame() {
    await Playroom.init('your-api-key');
    
    // Assign roles to players
    this.assignRoles();
    
    // Set shared objectives
    this.setupObjectives();
    
    // Handle team communication
    this.setupTeamChat();
  }
  
  assignRoles() {
    const players = Playroom.getPlayers();
    
    players.forEach((player, index) => {
      const role = this.roles[index % this.roles.length];
      Playroom.setState(`players.${player.id}.role`, role);
      Playroom.setState(`players.${player.id}.abilities`, this.getRoleAbilities(role));
    });
  }
  
  setupObjectives() {
    const objectives = [
      { id: 'collect_items', target: 10, current: 0, assignedTo: 'team' },
      { id: 'defeat_boss', target: 1, current: 0, assignedTo: 'team' },
      { id: 'defend_base', target: 300, current: 300, assignedTo: 'team' } // 5 minutes
    ];
    
    Playroom.setState('game.objectives', objectives);
  }
  
  updateObjective(objectiveId, progress) {
    const objectives = Playroom.getState('game.objectives');
    const objective = objectives.find(obj => obj.id === objectiveId);
    
    if (objective) {
      objective.current += progress;
      Playroom.setState('game.objectives', objectives);
      
      // Check if objective completed
      if (objective.current >= objective.target) {
        this.objectiveCompleted(objectiveId);
      }
    }
  }
  
  objectiveCompleted(objectiveId) {
    Playroom.rpc('objectiveCompleted', { objectiveId });
    
    // Check if all objectives are complete
    const objectives = Playroom.getState('game.objectives');
    const allComplete = objectives.every(obj => obj.current >= obj.target);
    
    if (allComplete) {
      this.teamVictory();
    }
  }
}
```

### Examples
- Dungeon crawlers
- Survival games
- Puzzle games
- Tower defense

## Competitive Games

Players compete against each other for victory.

### Characteristics
- **Individual Goals**: Each player tries to win
- **Direct Competition**: Players actively oppose each other
- **Skill-Based**: Player ability determines outcome
- **Zero-Sum**: One player's gain is another's loss

### Implementation

```javascript
class CompetitiveGame {
  constructor() {
    this.leaderboard = [];
    this.matchTimer = 300; // 5 minutes
  }
  
  async initGame() {
    await Playroom.init('your-api-key');
    
    // Initialize competitive state
    this.setupCompetition();
    this.startMatch();
  }
  
  setupCompetition() {
    const players = Playroom.getPlayers();
    
    const leaderboard = players.map(player => ({
      playerId: player.id,
      name: player.name,
      score: 0,
      kills: 0,
      deaths: 0,
      rank: 0
    }));
    
    Playroom.setState('game', {
      phase: 'playing',
      leaderboard: leaderboard,
      matchStartTime: Date.now(),
      matchDuration: this.matchTimer * 1000
    });
  }
  
  updateScore(playerId, scoreChange) {
    const gameState = Playroom.getState('game');
    const playerEntry = gameState.leaderboard.find(p => p.playerId === playerId);
    
    if (playerEntry) {
      playerEntry.score += scoreChange;
      
      // Update rankings
      this.updateRankings(gameState.leaderboard);
      
      Playroom.setState('game.leaderboard', gameState.leaderboard);
    }
  }
  
  updateRankings(leaderboard) {
    // Sort by score (descending)
    leaderboard.sort((a, b) => b.score - a.score);
    
    // Assign ranks
    leaderboard.forEach((player, index) => {
      player.rank = index + 1;
    });
  }
  
  checkWinCondition() {
    const gameState = Playroom.getState('game');
    const leader = gameState.leaderboard[0];
    
    // Win by score threshold
    if (leader.score >= 1000) {
      this.endMatch(leader.playerId);
    }
    
    // Win by time limit
    const elapsed = Date.now() - gameState.matchStartTime;
    if (elapsed >= gameState.matchDuration) {
      this.endMatch(leader.playerId);
    }
  }
}
```

### Examples
- Battle royale
- Racing competitions  
- Fighting tournaments
- Puzzle competitions

## Large-Scale Multiplayer

Games supporting many players simultaneously (10+ players).

### Characteristics
- **High Player Count**: 10-100+ simultaneous players
- **Scalability Challenges**: Network and performance optimization critical
- **Social Dynamics**: Complex player interactions
- **Persistent Worlds**: Often feature ongoing, persistent game states

### Implementation

```javascript
class LargeScaleGame {
  constructor() {
    this.maxPlayers = 50;
    this.regions = new Map(); // Spatial partitioning
    this.updateBatching = true;
  }
  
  async initGame() {
    await Playroom.init('your-api-key');
    
    // Set up spatial partitioning
    this.setupRegions();
    
    // Implement update batching
    this.setupBatchedUpdates();
    
    // Handle player culling
    this.setupPlayerCulling();
  }
  
  setupRegions() {
    // Divide game world into regions for optimization
    const regionSize = 1000;
    
    for (let x = 0; x < 5; x++) {
      for (let y = 0; y < 5; y++) {
        const regionId = `${x}_${y}`;
        this.regions.set(regionId, {
          id: regionId,
          bounds: {
            x: x * regionSize,
            y: y * regionSize,
            width: regionSize,
            height: regionSize
          },
          players: new Set(),
          entities: new Set()
        });
      }
    }
  }
  
  getPlayerRegion(position) {
    const regionX = Math.floor(position.x / 1000);
    const regionY = Math.floor(position.y / 1000);
    return `${regionX}_${regionY}`;
  }
  
  setupBatchedUpdates() {
    // Batch updates to reduce network traffic
    this.updateQueue = [];
    
    setInterval(() => {
      if (this.updateQueue.length > 0) {
        Playroom.setState('batchedUpdates', {
          updates: this.updateQueue,
          timestamp: Date.now()
        });
        this.updateQueue = [];
      }
    }, 100); // Send batches every 100ms
  }
  
  queueUpdate(update) {
    this.updateQueue.push(update);
  }
  
  setupPlayerCulling() {
    // Only send updates for nearby players
    const myPlayer = Playroom.getMyPlayer();
    const myPosition = Playroom.getState(`players.${myPlayer.id}.position`);
    
    if (myPosition) {
      const myRegion = this.getPlayerRegion(myPosition);
      const nearbyRegions = this.getNearbyRegions(myRegion);
      
      // Only process updates from nearby regions
      this.processNearbyUpdates(nearbyRegions);
    }
  }
  
  processNearbyUpdates(nearbyRegions) {
    nearbyRegions.forEach(regionId => {
      const region = this.regions.get(regionId);
      if (region) {
        // Process updates only for players in this region
        region.players.forEach(playerId => {
          this.processPlayerUpdate(playerId);
        });
      }
    });
  }
}
```

### Examples
- MMORPGs
- Battle royale (100 players)
- Social worlds
- Massive PvP battles

## Party Games

Casual, social games for groups of friends.

### Characteristics
- **Easy to Learn**: Simple rules and controls
- **Social Focus**: Emphasis on fun and interaction
- **Quick Rounds**: Short game sessions
- **Inclusive**: Accommodates different skill levels

### Implementation

```javascript
class PartyGame {
  constructor() {
    this.minigames = [
      'racing', 'trivia', 'drawing', 'memory'
    ];
    this.currentMinigame = null;
    this.roundDuration = 60; // 1 minute rounds
  }
  
  async initGame() {
    await Playroom.init('your-api-key');
    
    this.setupPartyMode();
    this.startNextMinigame();
  }
  
  setupPartyMode() {
    Playroom.setState('party', {
      totalRounds: 5,
      currentRound: 1,
      scores: {},
      phase: 'waiting'
    });
    
    // Initialize player scores
    const players = Playroom.getPlayers();
    players.forEach(player => {
      Playroom.setState(`party.scores.${player.id}`, 0);
    });
  }
  
  startNextMinigame() {
    const partyState = Playroom.getState('party');
    
    if (partyState.currentRound > partyState.totalRounds) {
      this.endParty();
      return;
    }
    
    // Randomly select minigame
    const randomGame = this.minigames[Math.floor(Math.random() * this.minigames.length)];
    
    Playroom.setState('party', {
      ...partyState,
      currentMinigame: randomGame,
      phase: 'playing',
      roundStartTime: Date.now()
    });
    
    this.initMinigame(randomGame);
  }
  
  initMinigame(gameType) {
    switch (gameType) {
      case 'racing':
        this.initRacingMinigame();
        break;
      case 'trivia':
        this.initTriviaMinigame();
        break;
      case 'drawing':
        this.initDrawingMinigame();
        break;
      case 'memory':
        this.initMemoryMinigame();
        break;
    }
    
    // Auto-end round after duration
    setTimeout(() => {
      this.endMinigame();
    }, this.roundDuration * 1000);
  }
  
  endMinigame() {
    this.calculateRoundWinner();
    
    const partyState = Playroom.getState('party');
    Playroom.setState('party.currentRound', partyState.currentRound + 1);
    
    // Show results for 3 seconds, then next round
    setTimeout(() => {
      this.startNextMinigame();
    }, 3000);
  }
}
```

### Examples
- Mario Party style games
- Jackbox games
- Trivia competitions
- Drawing games

## Mobile Multiplayer Considerations

Special considerations for mobile multiplayer games.

### Touch Controls
```javascript
class MobileMultiplayerGame {
  setupTouchControls() {
    // Virtual joystick for movement
    const joystick = new VirtualJoystick({
      container: 'joystick-container',
      onMove: (data) => {
        this.updatePlayerMovement(data);
      }
    });
    
    // Touch buttons for actions
    this.setupTouchButtons();
  }
  
  setupTouchButtons() {
    const jumpButton = document.getElementById('jump-btn');
    jumpButton.addEventListener('touchstart', () => {
      Playroom.rpc('playerJump', {});
    });
    
    const attackButton = document.getElementById('attack-btn');
    attackButton.addEventListener('touchstart', () => {
      Playroom.rpc('playerAttack', {});
    });
  }
}
```

### Battery Optimization
```javascript
class BatteryOptimizedGame {
  constructor() {
    this.updateRate = this.detectDeviceCapability();
    this.powerSaveMode = false;
  }
  
  detectDeviceCapability() {
    // Adjust update rate based on device
    const isLowEnd = navigator.hardwareConcurrency <= 2;
    return isLowEnd ? 30 : 60; // 30 or 60 FPS
  }
  
  enablePowerSaveMode() {
    this.powerSaveMode = true;
    this.updateRate = 15; // Reduce to 15 FPS
    
    // Reduce visual effects
    this.disableParticles();
    this.reduceSyncFrequency();
  }
}
```

## Best Practices by Game Type

### Turn-Based
- Implement turn timeouts
- Save game state for resume
- Handle disconnections gracefully
- Validate moves server-side

### Real-Time
- Use client-side prediction
- Implement lag compensation
- Prioritize critical updates
- Handle network jitter

### Competitive
- Implement anti-cheat measures
- Fair matchmaking systems
- Spectator modes
- Replay systems

### Cooperative
- Clear role definitions
- Progress sharing
- Communication tools
- Revival/rescue mechanics

### Large-Scale
- Spatial optimization
- Update batching
- Player culling
- Load balancing

Choose the right approach based on your game's requirements and target audience! 